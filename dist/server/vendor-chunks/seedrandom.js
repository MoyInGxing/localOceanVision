"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/seedrandom";
exports.ids = ["vendor-chunks/seedrandom"];
exports.modules = {

/***/ "(ssr)/./node_modules/seedrandom/index.js":
/*!******************************************!*\
  !*** ./node_modules/seedrandom/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// A library of seedable RNGs implemented in Javascript.\n//\n// Usage:\n//\n// var seedrandom = require('seedrandom');\n// var random = seedrandom(1); // or any seed.\n// var x = random();       // 0 <= x < 1.  Every bit is random.\n// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.\n// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.\n// Period: ~2^116\n// Reported to pass all BigCrush tests.\n\nvar alea = __webpack_require__(/*! ./lib/alea */ \"(ssr)/./node_modules/seedrandom/lib/alea.js\");\n// xor128, a pure xor-shift generator by George Marsaglia.\n// Period: 2^128-1.\n// Reported to fail: MatrixRank and LinearComp.\nvar xor128 = __webpack_require__(/*! ./lib/xor128 */ \"(ssr)/./node_modules/seedrandom/lib/xor128.js\");\n// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.\n// Period: 2^192-2^32\n// Reported to fail: CollisionOver, SimpPoker, and LinearComp.\nvar xorwow = __webpack_require__(/*! ./lib/xorwow */ \"(ssr)/./node_modules/seedrandom/lib/xorwow.js\");\n// xorshift7, by François Panneton and Pierre L'ecuyer, takes\n// a different approach: it adds robustness by allowing more shifts\n// than Marsaglia's original three.  It is a 7-shift generator\n// with 256 bits, that passes BigCrush with no systmatic failures.\n// Period 2^256-1.\n// No systematic BigCrush failures reported.\nvar xorshift7 = __webpack_require__(/*! ./lib/xorshift7 */ \"(ssr)/./node_modules/seedrandom/lib/xorshift7.js\");\n// xor4096, by Richard Brent, is a 4096-bit xor-shift with a\n// very long period that also adds a Weyl generator. It also passes\n// BigCrush with no systematic failures.  Its long period may\n// be useful if you have many generators and need to avoid\n// collisions.\n// Period: 2^4128-2^32.\n// No systematic BigCrush failures reported.\nvar xor4096 = __webpack_require__(/*! ./lib/xor4096 */ \"(ssr)/./node_modules/seedrandom/lib/xor4096.js\");\n// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random\n// number generator derived from ChaCha, a modern stream cipher.\n// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n// Period: ~2^127\n// No systematic BigCrush failures reported.\nvar tychei = __webpack_require__(/*! ./lib/tychei */ \"(ssr)/./node_modules/seedrandom/lib/tychei.js\");\n// The original ARC4-based prng included in this library.\n// Period: ~2^1600\nvar sr = __webpack_require__(/*! ./seedrandom */ \"(ssr)/./node_modules/seedrandom/seedrandom.js\");\nsr.alea = alea;\nsr.xor128 = xor128;\nsr.xorwow = xorwow;\nsr.xorshift7 = xorshift7;\nsr.xor4096 = xor4096;\nsr.tychei = tychei;\nmodule.exports = sr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3REFBd0Q7QUFDeEQsRUFBRTtBQUNGLFNBQVM7QUFDVCxFQUFFO0FBQ0YsMENBQTBDO0FBQzFDLDhDQUE4QztBQUM5QywrREFBK0Q7QUFDL0QsaUVBQWlFO0FBRWpFLG1FQUFtRTtBQUNuRSxpQkFBaUI7QUFDakIsdUNBQXVDOztBQUN2QyxJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVuQiwwREFBMEQ7QUFDMUQsbUJBQW1CO0FBQ25CLCtDQUErQztBQUMvQyxJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUVyQixtRUFBbUU7QUFDbkUscUJBQXFCO0FBQ3JCLDhEQUE4RDtBQUM5RCxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQztBQUVyQiw2REFBNkQ7QUFDN0QsbUVBQW1FO0FBQ25FLDhEQUE4RDtBQUM5RCxrRUFBa0U7QUFDbEUsa0JBQWtCO0FBQ2xCLDRDQUE0QztBQUM1QyxJQUFJRyxZQUFZSCxtQkFBT0EsQ0FBQztBQUV4Qiw0REFBNEQ7QUFDNUQsbUVBQW1FO0FBQ25FLDZEQUE2RDtBQUM3RCwwREFBMEQ7QUFDMUQsY0FBYztBQUNkLHVCQUF1QjtBQUN2Qiw0Q0FBNEM7QUFDNUMsSUFBSUksVUFBVUosbUJBQU9BLENBQUM7QUFFdEIsdUVBQXVFO0FBQ3ZFLGdFQUFnRTtBQUNoRSxxREFBcUQ7QUFDckQsaUJBQWlCO0FBQ2pCLDRDQUE0QztBQUM1QyxJQUFJSyxTQUFTTCxtQkFBT0EsQ0FBQztBQUVyQix5REFBeUQ7QUFDekQsa0JBQWtCO0FBQ2xCLElBQUlNLEtBQUtOLG1CQUFPQSxDQUFDO0FBRWpCTSxHQUFHUCxJQUFJLEdBQUdBO0FBQ1ZPLEdBQUdMLE1BQU0sR0FBR0E7QUFDWkssR0FBR0osTUFBTSxHQUFHQTtBQUNaSSxHQUFHSCxTQUFTLEdBQUdBO0FBQ2ZHLEdBQUdGLE9BQU8sR0FBR0E7QUFDYkUsR0FBR0QsTUFBTSxHQUFHQTtBQUVaRSxPQUFPQyxPQUFPLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtb2NlYW4tZmFybS8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2luZGV4LmpzPzRlODEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBsaWJyYXJ5IG9mIHNlZWRhYmxlIFJOR3MgaW1wbGVtZW50ZWQgaW4gSmF2YXNjcmlwdC5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoJ3NlZWRyYW5kb20nKTtcbi8vIHZhciByYW5kb20gPSBzZWVkcmFuZG9tKDEpOyAvLyBvciBhbnkgc2VlZC5cbi8vIHZhciB4ID0gcmFuZG9tKCk7ICAgICAgIC8vIDAgPD0geCA8IDEuICBFdmVyeSBiaXQgaXMgcmFuZG9tLlxuLy8gdmFyIHggPSByYW5kb20ucXVpY2soKTsgLy8gMCA8PSB4IDwgMS4gIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cblxuLy8gYWxlYSwgYSA1My1iaXQgbXVsdGlwbHktd2l0aC1jYXJyeSBnZW5lcmF0b3IgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cbi8vIFBlcmlvZDogfjJeMTE2XG4vLyBSZXBvcnRlZCB0byBwYXNzIGFsbCBCaWdDcnVzaCB0ZXN0cy5cbnZhciBhbGVhID0gcmVxdWlyZSgnLi9saWIvYWxlYScpO1xuXG4vLyB4b3IxMjgsIGEgcHVyZSB4b3Itc2hpZnQgZ2VuZXJhdG9yIGJ5IEdlb3JnZSBNYXJzYWdsaWEuXG4vLyBQZXJpb2Q6IDJeMTI4LTEuXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBNYXRyaXhSYW5rIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcjEyOCA9IHJlcXVpcmUoJy4vbGliL3hvcjEyOCcpO1xuXG4vLyB4b3J3b3csIEdlb3JnZSBNYXJzYWdsaWEncyAxNjAtYml0IHhvci1zaGlmdCBjb21iaW5lZCBwbHVzIHdleWwuXG4vLyBQZXJpb2Q6IDJeMTkyLTJeMzJcbi8vIFJlcG9ydGVkIHRvIGZhaWw6IENvbGxpc2lvbk92ZXIsIFNpbXBQb2tlciwgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yd293ID0gcmVxdWlyZSgnLi9saWIveG9yd293Jyk7XG5cbi8vIHhvcnNoaWZ0NywgYnkgRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXIsIHRha2VzXG4vLyBhIGRpZmZlcmVudCBhcHByb2FjaDogaXQgYWRkcyByb2J1c3RuZXNzIGJ5IGFsbG93aW5nIG1vcmUgc2hpZnRzXG4vLyB0aGFuIE1hcnNhZ2xpYSdzIG9yaWdpbmFsIHRocmVlLiAgSXQgaXMgYSA3LXNoaWZ0IGdlbmVyYXRvclxuLy8gd2l0aCAyNTYgYml0cywgdGhhdCBwYXNzZXMgQmlnQ3J1c2ggd2l0aCBubyBzeXN0bWF0aWMgZmFpbHVyZXMuXG4vLyBQZXJpb2QgMl4yNTYtMS5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yc2hpZnQ3ID0gcmVxdWlyZSgnLi9saWIveG9yc2hpZnQ3Jyk7XG5cbi8vIHhvcjQwOTYsIGJ5IFJpY2hhcmQgQnJlbnQsIGlzIGEgNDA5Ni1iaXQgeG9yLXNoaWZ0IHdpdGggYVxuLy8gdmVyeSBsb25nIHBlcmlvZCB0aGF0IGFsc28gYWRkcyBhIFdleWwgZ2VuZXJhdG9yLiBJdCBhbHNvIHBhc3Nlc1xuLy8gQmlnQ3J1c2ggd2l0aCBubyBzeXN0ZW1hdGljIGZhaWx1cmVzLiAgSXRzIGxvbmcgcGVyaW9kIG1heVxuLy8gYmUgdXNlZnVsIGlmIHlvdSBoYXZlIG1hbnkgZ2VuZXJhdG9ycyBhbmQgbmVlZCB0byBhdm9pZFxuLy8gY29sbGlzaW9ucy5cbi8vIFBlcmlvZDogMl40MTI4LTJeMzIuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcjQwOTYgPSByZXF1aXJlKCcuL2xpYi94b3I0MDk2Jyk7XG5cbi8vIFR5Y2hlLWksIGJ5IFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqbywgaXMgYSBiaXQtc2hpZnRpbmcgcmFuZG9tXG4vLyBudW1iZXIgZ2VuZXJhdG9yIGRlcml2ZWQgZnJvbSBDaGFDaGEsIGEgbW9kZXJuIHN0cmVhbSBjaXBoZXIuXG4vLyBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuLy8gUGVyaW9kOiB+Ml4xMjdcbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgdHljaGVpID0gcmVxdWlyZSgnLi9saWIvdHljaGVpJyk7XG5cbi8vIFRoZSBvcmlnaW5hbCBBUkM0LWJhc2VkIHBybmcgaW5jbHVkZWQgaW4gdGhpcyBsaWJyYXJ5LlxuLy8gUGVyaW9kOiB+Ml4xNjAwXG52YXIgc3IgPSByZXF1aXJlKCcuL3NlZWRyYW5kb20nKTtcblxuc3IuYWxlYSA9IGFsZWE7XG5zci54b3IxMjggPSB4b3IxMjg7XG5zci54b3J3b3cgPSB4b3J3b3c7XG5zci54b3JzaGlmdDcgPSB4b3JzaGlmdDc7XG5zci54b3I0MDk2ID0geG9yNDA5NjtcbnNyLnR5Y2hlaSA9IHR5Y2hlaTtcblxubW9kdWxlLmV4cG9ydHMgPSBzcjtcbiJdLCJuYW1lcyI6WyJhbGVhIiwicmVxdWlyZSIsInhvcjEyOCIsInhvcndvdyIsInhvcnNoaWZ0NyIsInhvcjQwOTYiLCJ0eWNoZWkiLCJzciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/alea.js":
/*!*********************************************!*\
  !*** ./node_modules/seedrandom/lib/alea.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010\n// http://baagoe.com/en/RandomMusings/javascript/\n// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n// Original work is under MIT license -\n// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n(function(global, module1, define1) {\n    function Alea(seed) {\n        var me = this, mash = Mash();\n        me.next = function() {\n            var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32\n            me.s0 = me.s1;\n            me.s1 = me.s2;\n            return me.s2 = t - (me.c = t | 0);\n        };\n        // Apply the seeding algorithm from Baagoe.\n        me.c = 1;\n        me.s0 = mash(\" \");\n        me.s1 = mash(\" \");\n        me.s2 = mash(\" \");\n        me.s0 -= mash(seed);\n        if (me.s0 < 0) {\n            me.s0 += 1;\n        }\n        me.s1 -= mash(seed);\n        if (me.s1 < 0) {\n            me.s1 += 1;\n        }\n        me.s2 -= mash(seed);\n        if (me.s2 < 0) {\n            me.s2 += 1;\n        }\n        mash = null;\n    }\n    function copy(f, t) {\n        t.c = f.c;\n        t.s0 = f.s0;\n        t.s1 = f.s1;\n        t.s2 = f.s2;\n        return t;\n    }\n    function impl(seed, opts) {\n        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;\n        prng.int32 = function() {\n            return xg.next() * 0x100000000 | 0;\n        };\n        prng.double = function() {\n            return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n        };\n        prng.quick = prng;\n        if (state) {\n            if (typeof state == \"object\") copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    function Mash() {\n        var n = 0xefc8249d;\n        var mash = function(data) {\n            data = String(data);\n            for(var i = 0; i < data.length; i++){\n                n += data.charCodeAt(i);\n                var h = 0.02519603282416938 * n;\n                n = h >>> 0;\n                h -= n;\n                h *= n;\n                n = h >>> 0;\n                h -= n;\n                n += h * 0x100000000; // 2^32\n            }\n            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n        };\n        return mash;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.alea = impl;\n    }\n})(void 0,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvYWxlYS5qcyIsIm1hcHBpbmdzIjoiOztBQUFBLHNFQUFzRTtBQUN0RSxpREFBaUQ7QUFDakQsMEVBQTBFO0FBQzFFLHVDQUF1QztBQUV2Qyw0REFBNEQ7QUFDNUQsRUFBRTtBQUNGLCtFQUErRTtBQUMvRSxnRkFBZ0Y7QUFDaEYsK0VBQStFO0FBQy9FLDRFQUE0RTtBQUM1RSx3RUFBd0U7QUFDeEUsMkRBQTJEO0FBQzNELEVBQUU7QUFDRiw2RUFBNkU7QUFDN0Usc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiw2RUFBNkU7QUFDN0UsMkVBQTJFO0FBQzNFLDhFQUE4RTtBQUM5RSx5RUFBeUU7QUFDekUsZ0ZBQWdGO0FBQ2hGLDRFQUE0RTtBQUM1RSxnQkFBZ0I7QUFJZixVQUFTQSxNQUFNLEVBQUVDLE9BQU0sRUFBRUMsT0FBTTtJQUVoQyxTQUFTQyxLQUFLQyxJQUFJO1FBQ2hCLElBQUlDLEtBQUssSUFBSSxFQUFFQyxPQUFPQztRQUV0QkYsR0FBR0csSUFBSSxHQUFHO1lBQ1IsSUFBSUMsSUFBSSxVQUFVSixHQUFHSyxFQUFFLEdBQUdMLEdBQUdNLENBQUMsR0FBRyx3QkFBd0IsUUFBUTtZQUNqRU4sR0FBR0ssRUFBRSxHQUFHTCxHQUFHTyxFQUFFO1lBQ2JQLEdBQUdPLEVBQUUsR0FBR1AsR0FBR1EsRUFBRTtZQUNiLE9BQU9SLEdBQUdRLEVBQUUsR0FBR0osSUFBS0osQ0FBQUEsR0FBR00sQ0FBQyxHQUFHRixJQUFJO1FBQ2pDO1FBRUEsMkNBQTJDO1FBQzNDSixHQUFHTSxDQUFDLEdBQUc7UUFDUE4sR0FBR0ssRUFBRSxHQUFHSixLQUFLO1FBQ2JELEdBQUdPLEVBQUUsR0FBR04sS0FBSztRQUNiRCxHQUFHUSxFQUFFLEdBQUdQLEtBQUs7UUFDYkQsR0FBR0ssRUFBRSxJQUFJSixLQUFLRjtRQUNkLElBQUlDLEdBQUdLLEVBQUUsR0FBRyxHQUFHO1lBQUVMLEdBQUdLLEVBQUUsSUFBSTtRQUFHO1FBQzdCTCxHQUFHTyxFQUFFLElBQUlOLEtBQUtGO1FBQ2QsSUFBSUMsR0FBR08sRUFBRSxHQUFHLEdBQUc7WUFBRVAsR0FBR08sRUFBRSxJQUFJO1FBQUc7UUFDN0JQLEdBQUdRLEVBQUUsSUFBSVAsS0FBS0Y7UUFDZCxJQUFJQyxHQUFHUSxFQUFFLEdBQUcsR0FBRztZQUFFUixHQUFHUSxFQUFFLElBQUk7UUFBRztRQUM3QlAsT0FBTztJQUNUO0lBRUEsU0FBU1EsS0FBS0MsQ0FBQyxFQUFFTixDQUFDO1FBQ2hCQSxFQUFFRSxDQUFDLEdBQUdJLEVBQUVKLENBQUM7UUFDVEYsRUFBRUMsRUFBRSxHQUFHSyxFQUFFTCxFQUFFO1FBQ1hELEVBQUVHLEVBQUUsR0FBR0csRUFBRUgsRUFBRTtRQUNYSCxFQUFFSSxFQUFFLEdBQUdFLEVBQUVGLEVBQUU7UUFDWCxPQUFPSjtJQUNUO0lBRUEsU0FBU08sS0FBS1osSUFBSSxFQUFFYSxJQUFJO1FBQ3RCLElBQUlDLEtBQUssSUFBSWYsS0FBS0MsT0FDZGUsUUFBUUYsUUFBUUEsS0FBS0UsS0FBSyxFQUMxQkMsT0FBT0YsR0FBR1YsSUFBSTtRQUNsQlksS0FBS0MsS0FBSyxHQUFHO1lBQWEsT0FBTyxHQUFJYixJQUFJLEtBQUssY0FBZTtRQUFHO1FBQ2hFWSxLQUFLRSxNQUFNLEdBQUc7WUFDWixPQUFPRixTQUFTLENBQUNBLFNBQVMsV0FBVyxLQUFLLHdCQUF3QixRQUFRO1FBQzVFO1FBQ0FBLEtBQUtHLEtBQUssR0FBR0g7UUFDYixJQUFJRCxPQUFPO1lBQ1QsSUFBSSxPQUFPQSxTQUFVLFVBQVVMLEtBQUtLLE9BQU9EO1lBQzNDRSxLQUFLRCxLQUFLLEdBQUc7Z0JBQWEsT0FBT0wsS0FBS0ksSUFBSSxDQUFDO1lBQUk7UUFDakQ7UUFDQSxPQUFPRTtJQUNUO0lBRUEsU0FBU2I7UUFDUCxJQUFJaUIsSUFBSTtRQUVSLElBQUlsQixPQUFPLFNBQVNtQixJQUFJO1lBQ3RCQSxPQUFPQyxPQUFPRDtZQUNkLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRixLQUFLRyxNQUFNLEVBQUVELElBQUs7Z0JBQ3BDSCxLQUFLQyxLQUFLSSxVQUFVLENBQUNGO2dCQUNyQixJQUFJRyxJQUFJLHNCQUFzQk47Z0JBQzlCQSxJQUFJTSxNQUFNO2dCQUNWQSxLQUFLTjtnQkFDTE0sS0FBS047Z0JBQ0xBLElBQUlNLE1BQU07Z0JBQ1ZBLEtBQUtOO2dCQUNMQSxLQUFLTSxJQUFJLGFBQWEsT0FBTztZQUMvQjtZQUNBLE9BQU8sQ0FBQ04sTUFBTSxLQUFLLHdCQUF3QixRQUFRO1FBQ3JEO1FBRUEsT0FBT2xCO0lBQ1Q7SUFHQSxJQUFJTCxXQUFVQSxRQUFPOEIsT0FBTyxFQUFFO1FBQzVCOUIsUUFBTzhCLE9BQU8sR0FBR2Y7SUFDbkIsT0FBTyxJQUFJZCx3QkFBQUEsSUFBVUEsd0JBQVUsRUFBRTtRQUMvQkEsbUNBQU87WUFBYSxPQUFPYztRQUFNLENBQUM7QUFBQSxrR0FBQztJQUNyQyxPQUFPO1FBQ0wsSUFBSSxDQUFDaUIsSUFBSSxHQUFHakI7SUFDZDtBQUVBLEdBQ0UsUUFDQSxLQUFtQixJQUFZZixRQUMvQix3QkFBdUNDLENBQUcsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtb2NlYW4tZmFybS8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi9hbGVhLmpzPzhiYWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBwb3J0IG9mIGFuIGFsZ29yaXRobSBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLmNvbT4sIDIwMTBcbi8vIGh0dHA6Ly9iYWFnb2UuY29tL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdC9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ucXVpbmxhbi9iZXR0ZXItcmFuZG9tLW51bWJlcnMtZm9yLWphdmFzY3JpcHQtbWlycm9yXG4vLyBPcmlnaW5hbCB3b3JrIGlzIHVuZGVyIE1JVCBsaWNlbnNlIC1cblxuLy8gQ29weXJpZ2h0IChDKSAyMDEwIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2Uub3JnPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cblxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBBbGVhKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgbWFzaCA9IE1hc2goKTtcblxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAyMDkxNjM5ICogbWUuczAgKyBtZS5jICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgICBtZS5zMCA9IG1lLnMxO1xuICAgIG1lLnMxID0gbWUuczI7XG4gICAgcmV0dXJuIG1lLnMyID0gdCAtIChtZS5jID0gdCB8IDApO1xuICB9O1xuXG4gIC8vIEFwcGx5IHRoZSBzZWVkaW5nIGFsZ29yaXRobSBmcm9tIEJhYWdvZS5cbiAgbWUuYyA9IDE7XG4gIG1lLnMwID0gbWFzaCgnICcpO1xuICBtZS5zMSA9IG1hc2goJyAnKTtcbiAgbWUuczIgPSBtYXNoKCcgJyk7XG4gIG1lLnMwIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMCA8IDApIHsgbWUuczAgKz0gMTsgfVxuICBtZS5zMSAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczEgPCAwKSB7IG1lLnMxICs9IDE7IH1cbiAgbWUuczIgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMyIDwgMCkgeyBtZS5zMiArPSAxOyB9XG4gIG1hc2ggPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5jID0gZi5jO1xuICB0LnMwID0gZi5zMDtcbiAgdC5zMSA9IGYuczE7XG4gIHQuczIgPSBmLnMyO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBBbGVhKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0geGcubmV4dDtcbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSAqIDB4MTAwMDAwMDAwKSB8IDA7IH1cbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcHJuZygpICsgKHBybmcoKSAqIDB4MjAwMDAwIHwgMCkgKiAxLjExMDIyMzAyNDYyNTE1NjVlLTE2OyAvLyAyXi01M1xuICB9O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuZnVuY3Rpb24gTWFzaCgpIHtcbiAgdmFyIG4gPSAweGVmYzgyNDlkO1xuXG4gIHZhciBtYXNoID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGRhdGEgPSBTdHJpbmcoZGF0YSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIGggKj0gbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICB9XG4gICAgcmV0dXJuIChuID4+PiAwKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gIH07XG5cbiAgcmV0dXJuIG1hc2g7XG59XG5cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5hbGVhID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwibW9kdWxlIiwiZGVmaW5lIiwiQWxlYSIsInNlZWQiLCJtZSIsIm1hc2giLCJNYXNoIiwibmV4dCIsInQiLCJzMCIsImMiLCJzMSIsInMyIiwiY29weSIsImYiLCJpbXBsIiwib3B0cyIsInhnIiwic3RhdGUiLCJwcm5nIiwiaW50MzIiLCJkb3VibGUiLCJxdWljayIsIm4iLCJkYXRhIiwiU3RyaW5nIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJoIiwiZXhwb3J0cyIsImFtZCIsImFsZWEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/alea.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/tychei.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/tychei.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n// A Javascript implementaion of the \"Tyche-i\" prng algorithm by\n// Samuel Neves and Filipe Araujo.\n// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n(function(global, module1, define1) {\n    function XorGen(seed) {\n        var me = this, strseed = \"\";\n        // Set up generator function.\n        me.next = function() {\n            var b = me.b, c = me.c, d = me.d, a = me.a;\n            b = b << 25 ^ b >>> 7 ^ c;\n            c = c - d | 0;\n            d = d << 24 ^ d >>> 8 ^ a;\n            a = a - b | 0;\n            me.b = b = b << 20 ^ b >>> 12 ^ c;\n            me.c = c = c - d | 0;\n            me.d = d << 16 ^ c >>> 16 ^ a;\n            return me.a = a - b | 0;\n        };\n        /* The following is non-inverted tyche, which has better internal\n   * bit diffusion, but which is about 25% slower than tyche-i in JS.\n  me.next = function() {\n    var a = me.a, b = me.b, c = me.c, d = me.d;\n    a = (me.a + me.b | 0) >>> 0;\n    d = me.d ^ a; d = d << 16 ^ d >>> 16;\n    c = me.c + d | 0;\n    b = me.b ^ c; b = b << 12 ^ d >>> 20;\n    me.a = a = a + b | 0;\n    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;\n    me.c = c = c + d | 0;\n    b = b ^ c;\n    return me.b = (b << 7 ^ b >>> 25);\n  }\n  */ me.a = 0;\n        me.b = 0;\n        me.c = 2654435769 | 0;\n        me.d = 1367130551;\n        if (seed === Math.floor(seed)) {\n            // Integer seed.\n            me.a = seed / 0x100000000 | 0;\n            me.b = seed | 0;\n        } else {\n            // String seed.\n            strseed += seed;\n        }\n        // Mix in string seed, then discard an initial batch of 64 values.\n        for(var k = 0; k < strseed.length + 20; k++){\n            me.b ^= strseed.charCodeAt(k) | 0;\n            me.next();\n        }\n    }\n    function copy(f, t) {\n        t.a = f.a;\n        t.b = f.b;\n        t.c = f.c;\n        t.d = f.d;\n        return t;\n    }\n    ;\n    function impl(seed, opts) {\n        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {\n            return (xg.next() >>> 0) / 0x100000000;\n        };\n        prng.double = function() {\n            do {\n                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);\n            }while (result === 0);\n            return result;\n        };\n        prng.int32 = xg.next;\n        prng.quick = prng;\n        if (state) {\n            if (typeof state == \"object\") copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.tychei = impl;\n    }\n})(void 0,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvdHljaGVpLmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsZ0VBQWdFO0FBQ2hFLGtDQUFrQztBQUNsQyx5REFBeUQ7QUFFeEQsVUFBU0EsTUFBTSxFQUFFQyxPQUFNLEVBQUVDLE9BQU07SUFFaEMsU0FBU0MsT0FBT0MsSUFBSTtRQUNsQixJQUFJQyxLQUFLLElBQUksRUFBRUMsVUFBVTtRQUV6Qiw2QkFBNkI7UUFDN0JELEdBQUdFLElBQUksR0FBRztZQUNSLElBQUlDLElBQUlILEdBQUdHLENBQUMsRUFBRUMsSUFBSUosR0FBR0ksQ0FBQyxFQUFFQyxJQUFJTCxHQUFHSyxDQUFDLEVBQUVDLElBQUlOLEdBQUdNLENBQUM7WUFDMUNILElBQUksS0FBTSxLQUFPQSxNQUFNLElBQUtDO1lBQzVCQSxJQUFJLElBQUtDLElBQUs7WUFDZEEsSUFBSSxLQUFNLEtBQU9BLE1BQU0sSUFBS0M7WUFDNUJBLElBQUksSUFBS0gsSUFBSztZQUNkSCxHQUFHRyxDQUFDLEdBQUdBLElBQUksS0FBTSxLQUFPQSxNQUFNLEtBQU1DO1lBQ3BDSixHQUFHSSxDQUFDLEdBQUdBLElBQUksSUFBS0MsSUFBSztZQUNyQkwsR0FBR0ssQ0FBQyxHQUFHLEtBQU0sS0FBT0QsTUFBTSxLQUFNRTtZQUNoQyxPQUFPTixHQUFHTSxDQUFDLEdBQUcsSUFBS0gsSUFBSztRQUMxQjtRQUVBOzs7Ozs7Ozs7Ozs7OztFQWNBLEdBRUFILEdBQUdNLENBQUMsR0FBRztRQUNQTixHQUFHRyxDQUFDLEdBQUc7UUFDUEgsR0FBR0ksQ0FBQyxHQUFHLGFBQWE7UUFDcEJKLEdBQUdLLENBQUMsR0FBRztRQUVQLElBQUlOLFNBQVNRLEtBQUtDLEtBQUssQ0FBQ1QsT0FBTztZQUM3QixnQkFBZ0I7WUFDaEJDLEdBQUdNLENBQUMsR0FBRyxPQUFRLGNBQWU7WUFDOUJOLEdBQUdHLENBQUMsR0FBR0osT0FBTztRQUNoQixPQUFPO1lBQ0wsZUFBZTtZQUNmRSxXQUFXRjtRQUNiO1FBRUEsa0VBQWtFO1FBQ2xFLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJUixRQUFRUyxNQUFNLEdBQUcsSUFBSUQsSUFBSztZQUM1Q1QsR0FBR0csQ0FBQyxJQUFJRixRQUFRVSxVQUFVLENBQUNGLEtBQUs7WUFDaENULEdBQUdFLElBQUk7UUFDVDtJQUNGO0lBRUEsU0FBU1UsS0FBS0MsQ0FBQyxFQUFFQyxDQUFDO1FBQ2hCQSxFQUFFUixDQUFDLEdBQUdPLEVBQUVQLENBQUM7UUFDVFEsRUFBRVgsQ0FBQyxHQUFHVSxFQUFFVixDQUFDO1FBQ1RXLEVBQUVWLENBQUMsR0FBR1MsRUFBRVQsQ0FBQztRQUNUVSxFQUFFVCxDQUFDLEdBQUdRLEVBQUVSLENBQUM7UUFDVCxPQUFPUztJQUNUOztJQUVBLFNBQVNDLEtBQUtoQixJQUFJLEVBQUVpQixJQUFJO1FBQ3RCLElBQUlDLEtBQUssSUFBSW5CLE9BQU9DLE9BQ2hCbUIsUUFBUUYsUUFBUUEsS0FBS0UsS0FBSyxFQUMxQkMsT0FBTztZQUFhLE9BQU8sQ0FBQ0YsR0FBR2YsSUFBSSxPQUFPLEtBQUs7UUFBYTtRQUNoRWlCLEtBQUtDLE1BQU0sR0FBRztZQUNaLEdBQUc7Z0JBQ0QsSUFBSUMsTUFBTUosR0FBR2YsSUFBSSxPQUFPLElBQ3BCb0IsTUFBTSxDQUFDTCxHQUFHZixJQUFJLE9BQU8sS0FBSyxhQUMxQnFCLFNBQVMsQ0FBQ0YsTUFBTUMsR0FBRSxJQUFNLE1BQUssRUFBQztZQUNwQyxRQUFTQyxXQUFXLEdBQUc7WUFDdkIsT0FBT0E7UUFDVDtRQUNBSixLQUFLSyxLQUFLLEdBQUdQLEdBQUdmLElBQUk7UUFDcEJpQixLQUFLTSxLQUFLLEdBQUdOO1FBQ2IsSUFBSUQsT0FBTztZQUNULElBQUksT0FBT0EsU0FBVSxVQUFVTixLQUFLTSxPQUFPRDtZQUMzQ0UsS0FBS0QsS0FBSyxHQUFHO2dCQUFhLE9BQU9OLEtBQUtLLElBQUksQ0FBQztZQUFJO1FBQ2pEO1FBQ0EsT0FBT0U7SUFDVDtJQUVBLElBQUl2QixXQUFVQSxRQUFPOEIsT0FBTyxFQUFFO1FBQzVCOUIsUUFBTzhCLE9BQU8sR0FBR1g7SUFDbkIsT0FBTyxJQUFJbEIsd0JBQUFBLElBQVVBLHdCQUFVLEVBQUU7UUFDL0JBLG1DQUFPO1lBQWEsT0FBT2tCO1FBQU0sQ0FBQztBQUFBLGtHQUFDO0lBQ3JDLE9BQU87UUFDTCxJQUFJLENBQUNhLE1BQU0sR0FBR2I7SUFDaEI7QUFFQSxHQUNFLFFBQ0EsS0FBbUIsSUFBWW5CLFFBQy9CLHdCQUF1Q0MsQ0FBRyw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC1vY2Vhbi1mYXJtLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcz9mNjIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcIlR5Y2hlLWlcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLlxuLy8gU2VlIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQsIGEgPSBtZS5hO1xuICAgIGIgPSAoYiA8PCAyNSkgXiAoYiA+Pj4gNykgXiBjO1xuICAgIGMgPSAoYyAtIGQpIHwgMDtcbiAgICBkID0gKGQgPDwgMjQpIF4gKGQgPj4+IDgpIF4gYTtcbiAgICBhID0gKGEgLSBiKSB8IDA7XG4gICAgbWUuYiA9IGIgPSAoYiA8PCAyMCkgXiAoYiA+Pj4gMTIpIF4gYztcbiAgICBtZS5jID0gYyA9IChjIC0gZCkgfCAwO1xuICAgIG1lLmQgPSAoZCA8PCAxNikgXiAoYyA+Pj4gMTYpIF4gYTtcbiAgICByZXR1cm4gbWUuYSA9IChhIC0gYikgfCAwO1xuICB9O1xuXG4gIC8qIFRoZSBmb2xsb3dpbmcgaXMgbm9uLWludmVydGVkIHR5Y2hlLCB3aGljaCBoYXMgYmV0dGVyIGludGVybmFsXG4gICAqIGJpdCBkaWZmdXNpb24sIGJ1dCB3aGljaCBpcyBhYm91dCAyNSUgc2xvd2VyIHRoYW4gdHljaGUtaSBpbiBKUy5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbWUuYSwgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZDtcbiAgICBhID0gKG1lLmEgKyBtZS5iIHwgMCkgPj4+IDA7XG4gICAgZCA9IG1lLmQgXiBhOyBkID0gZCA8PCAxNiBeIGQgPj4+IDE2O1xuICAgIGMgPSBtZS5jICsgZCB8IDA7XG4gICAgYiA9IG1lLmIgXiBjOyBiID0gYiA8PCAxMiBeIGQgPj4+IDIwO1xuICAgIG1lLmEgPSBhID0gYSArIGIgfCAwO1xuICAgIGQgPSBkIF4gYTsgbWUuZCA9IGQgPSBkIDw8IDggXiBkID4+PiAyNDtcbiAgICBtZS5jID0gYyA9IGMgKyBkIHwgMDtcbiAgICBiID0gYiBeIGM7XG4gICAgcmV0dXJuIG1lLmIgPSAoYiA8PCA3IF4gYiA+Pj4gMjUpO1xuICB9XG4gICovXG5cbiAgbWUuYSA9IDA7XG4gIG1lLmIgPSAwO1xuICBtZS5jID0gMjY1NDQzNTc2OSB8IDA7XG4gIG1lLmQgPSAxMzY3MTMwNTUxO1xuXG4gIGlmIChzZWVkID09PSBNYXRoLmZsb29yKHNlZWQpKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLmEgPSAoc2VlZCAvIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgbWUuYiA9IHNlZWQgfCAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgMjA7IGsrKykge1xuICAgIG1lLmIgXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYSA9IGYuYTtcbiAgdC5iID0gZi5iO1xuICB0LmMgPSBmLmM7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnR5Y2hlaSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIl0sIm5hbWVzIjpbImdsb2JhbCIsIm1vZHVsZSIsImRlZmluZSIsIlhvckdlbiIsInNlZWQiLCJtZSIsInN0cnNlZWQiLCJuZXh0IiwiYiIsImMiLCJkIiwiYSIsIk1hdGgiLCJmbG9vciIsImsiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiY29weSIsImYiLCJ0IiwiaW1wbCIsIm9wdHMiLCJ4ZyIsInN0YXRlIiwicHJuZyIsImRvdWJsZSIsInRvcCIsImJvdCIsInJlc3VsdCIsImludDMyIiwicXVpY2siLCJleHBvcnRzIiwiYW1kIiwidHljaGVpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/tychei.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/xor128.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xor128.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n// A Javascript implementaion of the \"xor128\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n(function(global, module1, define1) {\n    function XorGen(seed) {\n        var me = this, strseed = \"\";\n        me.x = 0;\n        me.y = 0;\n        me.z = 0;\n        me.w = 0;\n        // Set up generator function.\n        me.next = function() {\n            var t = me.x ^ me.x << 11;\n            me.x = me.y;\n            me.y = me.z;\n            me.z = me.w;\n            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;\n        };\n        if (seed === (seed | 0)) {\n            // Integer seed.\n            me.x = seed;\n        } else {\n            // String seed.\n            strseed += seed;\n        }\n        // Mix in string seed, then discard an initial batch of 64 values.\n        for(var k = 0; k < strseed.length + 64; k++){\n            me.x ^= strseed.charCodeAt(k) | 0;\n            me.next();\n        }\n    }\n    function copy(f, t) {\n        t.x = f.x;\n        t.y = f.y;\n        t.z = f.z;\n        t.w = f.w;\n        return t;\n    }\n    function impl(seed, opts) {\n        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {\n            return (xg.next() >>> 0) / 0x100000000;\n        };\n        prng.double = function() {\n            do {\n                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);\n            }while (result === 0);\n            return result;\n        };\n        prng.int32 = xg.next;\n        prng.quick = prng;\n        if (state) {\n            if (typeof state == \"object\") copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.xor128 = impl;\n    }\n})(void 0,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsK0RBQStEO0FBQy9ELGdFQUFnRTtBQUUvRCxVQUFTQSxNQUFNLEVBQUVDLE9BQU0sRUFBRUMsT0FBTTtJQUVoQyxTQUFTQyxPQUFPQyxJQUFJO1FBQ2xCLElBQUlDLEtBQUssSUFBSSxFQUFFQyxVQUFVO1FBRXpCRCxHQUFHRSxDQUFDLEdBQUc7UUFDUEYsR0FBR0csQ0FBQyxHQUFHO1FBQ1BILEdBQUdJLENBQUMsR0FBRztRQUNQSixHQUFHSyxDQUFDLEdBQUc7UUFFUCw2QkFBNkI7UUFDN0JMLEdBQUdNLElBQUksR0FBRztZQUNSLElBQUlDLElBQUlQLEdBQUdFLENBQUMsR0FBSUYsR0FBR0UsQ0FBQyxJQUFJO1lBQ3hCRixHQUFHRSxDQUFDLEdBQUdGLEdBQUdHLENBQUM7WUFDWEgsR0FBR0csQ0FBQyxHQUFHSCxHQUFHSSxDQUFDO1lBQ1hKLEdBQUdJLENBQUMsR0FBR0osR0FBR0ssQ0FBQztZQUNYLE9BQU9MLEdBQUdLLENBQUMsSUFBSSxHQUFJQSxDQUFDLEtBQUssS0FBTUUsSUFBS0EsTUFBTTtRQUM1QztRQUVBLElBQUlSLFNBQVVBLENBQUFBLE9BQU8sSUFBSTtZQUN2QixnQkFBZ0I7WUFDaEJDLEdBQUdFLENBQUMsR0FBR0g7UUFDVCxPQUFPO1lBQ0wsZUFBZTtZQUNmRSxXQUFXRjtRQUNiO1FBRUEsa0VBQWtFO1FBQ2xFLElBQUssSUFBSVMsSUFBSSxHQUFHQSxJQUFJUCxRQUFRUSxNQUFNLEdBQUcsSUFBSUQsSUFBSztZQUM1Q1IsR0FBR0UsQ0FBQyxJQUFJRCxRQUFRUyxVQUFVLENBQUNGLEtBQUs7WUFDaENSLEdBQUdNLElBQUk7UUFDVDtJQUNGO0lBRUEsU0FBU0ssS0FBS0MsQ0FBQyxFQUFFTCxDQUFDO1FBQ2hCQSxFQUFFTCxDQUFDLEdBQUdVLEVBQUVWLENBQUM7UUFDVEssRUFBRUosQ0FBQyxHQUFHUyxFQUFFVCxDQUFDO1FBQ1RJLEVBQUVILENBQUMsR0FBR1EsRUFBRVIsQ0FBQztRQUNURyxFQUFFRixDQUFDLEdBQUdPLEVBQUVQLENBQUM7UUFDVCxPQUFPRTtJQUNUO0lBRUEsU0FBU00sS0FBS2QsSUFBSSxFQUFFZSxJQUFJO1FBQ3RCLElBQUlDLEtBQUssSUFBSWpCLE9BQU9DLE9BQ2hCaUIsUUFBUUYsUUFBUUEsS0FBS0UsS0FBSyxFQUMxQkMsT0FBTztZQUFhLE9BQU8sQ0FBQ0YsR0FBR1QsSUFBSSxPQUFPLEtBQUs7UUFBYTtRQUNoRVcsS0FBS0MsTUFBTSxHQUFHO1lBQ1osR0FBRztnQkFDRCxJQUFJQyxNQUFNSixHQUFHVCxJQUFJLE9BQU8sSUFDcEJjLE1BQU0sQ0FBQ0wsR0FBR1QsSUFBSSxPQUFPLEtBQUssYUFDMUJlLFNBQVMsQ0FBQ0YsTUFBTUMsR0FBRSxJQUFNLE1BQUssRUFBQztZQUNwQyxRQUFTQyxXQUFXLEdBQUc7WUFDdkIsT0FBT0E7UUFDVDtRQUNBSixLQUFLSyxLQUFLLEdBQUdQLEdBQUdULElBQUk7UUFDcEJXLEtBQUtNLEtBQUssR0FBR047UUFDYixJQUFJRCxPQUFPO1lBQ1QsSUFBSSxPQUFPQSxTQUFVLFVBQVVMLEtBQUtLLE9BQU9EO1lBQzNDRSxLQUFLRCxLQUFLLEdBQUc7Z0JBQWEsT0FBT0wsS0FBS0ksSUFBSSxDQUFDO1lBQUk7UUFDakQ7UUFDQSxPQUFPRTtJQUNUO0lBRUEsSUFBSXJCLFdBQVVBLFFBQU80QixPQUFPLEVBQUU7UUFDNUI1QixRQUFPNEIsT0FBTyxHQUFHWDtJQUNuQixPQUFPLElBQUloQix3QkFBQUEsSUFBVUEsd0JBQVUsRUFBRTtRQUMvQkEsbUNBQU87WUFBYSxPQUFPZ0I7UUFBTSxDQUFDO0FBQUEsa0dBQUM7SUFDckMsT0FBTztRQUNMLElBQUksQ0FBQ2EsTUFBTSxHQUFHYjtJQUNoQjtBQUVBLEdBQ0UsUUFDQSxLQUFtQixJQUFZakIsUUFDL0Isd0JBQXVDQyxDQUFHLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LW9jZWFuLWZhcm0vLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzPzBhZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yMTI4XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG1lLnggXiAobWUueCA8PCAxMSk7XG4gICAgbWUueCA9IG1lLnk7XG4gICAgbWUueSA9IG1lLno7XG4gICAgbWUueiA9IG1lLnc7XG4gICAgcmV0dXJuIG1lLncgXj0gKG1lLncgPj4+IDE5KSBeIHQgXiAodCA+Pj4gOCk7XG4gIH07XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3IxMjggPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJtb2R1bGUiLCJkZWZpbmUiLCJYb3JHZW4iLCJzZWVkIiwibWUiLCJzdHJzZWVkIiwieCIsInkiLCJ6IiwidyIsIm5leHQiLCJ0IiwiayIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjb3B5IiwiZiIsImltcGwiLCJvcHRzIiwieGciLCJzdGF0ZSIsInBybmciLCJkb3VibGUiLCJ0b3AiLCJib3QiLCJyZXN1bHQiLCJpbnQzMiIsInF1aWNrIiwiZXhwb3J0cyIsImFtZCIsInhvcjEyOCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/xor128.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/xor4096.js":
/*!************************************************!*\
  !*** ./node_modules/seedrandom/lib/xor4096.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\n//\n// This fast non-cryptographic random number generator is designed for\n// use in Monte-Carlo algorithms. It combines a long-period xorshift\n// generator with a Weyl generator, and it passes all common batteries\n// of stasticial tests for randomness while consuming only a few nanoseconds\n// for each prng generated.  For background on the generator, see Brent's\n// paper: \"Some long-period random number generators using shifts and xors.\"\n// http://arxiv.org/pdf/1004.3115v1.pdf\n//\n// Usage:\n//\n// var xor4096 = require('xor4096');\n// random = xor4096(1);                        // Seed with int32 or string.\n// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.\n// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.\n//\n// For nonzero numeric keys, this impelementation provides a sequence\n// identical to that by Brent's xorgens 3 implementaion in C.  This\n// implementation also provides for initalizing the generator with\n// string seeds, or for saving and restoring the state of the generator.\n//\n// On Chrome, this prng benchmarks about 2.1 times slower than\n// Javascript's built-in Math.random().\n(function(global, module1, define1) {\n    function XorGen(seed) {\n        var me = this;\n        // Set up generator function.\n        me.next = function() {\n            var w = me.w, X = me.X, i = me.i, t, v;\n            // Update Weyl generator.\n            me.w = w = w + 0x61c88647 | 0;\n            // Update xor generator.\n            v = X[i + 34 & 127];\n            t = X[i = i + 1 & 127];\n            v ^= v << 13;\n            t ^= t << 17;\n            v ^= v >>> 15;\n            t ^= t >>> 12;\n            // Update Xor generator array state.\n            v = X[i] = v ^ t;\n            me.i = i;\n            // Result is the combination.\n            return v + (w ^ w >>> 16) | 0;\n        };\n        function init(me, seed) {\n            var t, v, i, j, w, X = [], limit = 128;\n            if (seed === (seed | 0)) {\n                // Numeric seeds initialize v, which is used to generates X.\n                v = seed;\n                seed = null;\n            } else {\n                // String seeds are mixed into v and X one character at a time.\n                seed = seed + \"\\x00\";\n                v = 0;\n                limit = Math.max(limit, seed.length);\n            }\n            // Initialize circular array and weyl value.\n            for(i = 0, j = -32; j < limit; ++j){\n                // Put the unicode characters into the array, and shuffle them.\n                if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);\n                // After 32 shuffles, take v as the starting w value.\n                if (j === 0) w = v;\n                v ^= v << 10;\n                v ^= v >>> 15;\n                v ^= v << 4;\n                v ^= v >>> 13;\n                if (j >= 0) {\n                    w = w + 0x61c88647 | 0; // Weyl.\n                    t = X[j & 127] ^= v + w; // Combine xor and weyl to init array.\n                    i = 0 == t ? i + 1 : 0; // Count zeroes.\n                }\n            }\n            // We have detected all zeroes; make the key nonzero.\n            if (i >= 128) {\n                X[(seed && seed.length || 0) & 127] = -1;\n            }\n            // Run the generator 512 times to further mix the state before using it.\n            // Factoring this as a function slows the main generator, so it is just\n            // unrolled here.  The weyl generator is not advanced while warming up.\n            i = 127;\n            for(j = 4 * 128; j > 0; --j){\n                v = X[i + 34 & 127];\n                t = X[i = i + 1 & 127];\n                v ^= v << 13;\n                t ^= t << 17;\n                v ^= v >>> 15;\n                t ^= t >>> 12;\n                X[i] = v ^ t;\n            }\n            // Storing state as object members is faster than using closure variables.\n            me.w = w;\n            me.X = X;\n            me.i = i;\n        }\n        init(me, seed);\n    }\n    function copy(f, t) {\n        t.i = f.i;\n        t.w = f.w;\n        t.X = f.X.slice();\n        return t;\n    }\n    ;\n    function impl(seed, opts) {\n        if (seed == null) seed = +new Date;\n        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {\n            return (xg.next() >>> 0) / 0x100000000;\n        };\n        prng.double = function() {\n            do {\n                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);\n            }while (result === 0);\n            return result;\n        };\n        prng.int32 = xg.next;\n        prng.quick = prng;\n        if (state) {\n            if (state.X) copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.xor4096 = impl;\n    }\n})(void 0,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcyIsIm1hcHBpbmdzIjoiOztBQUFBLDJFQUEyRTtBQUMzRSxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHlFQUF5RTtBQUN6RSw0RUFBNEU7QUFDNUUsdUNBQXVDO0FBQ3ZDLEVBQUU7QUFDRixTQUFTO0FBQ1QsRUFBRTtBQUNGLG9DQUFvQztBQUNwQyw0RUFBNEU7QUFDNUUsd0VBQXdFO0FBQ3hFLHdFQUF3RTtBQUN4RSxFQUFFO0FBQ0YscUVBQXFFO0FBQ3JFLG1FQUFtRTtBQUNuRSxrRUFBa0U7QUFDbEUsd0VBQXdFO0FBQ3hFLEVBQUU7QUFDRiw4REFBOEQ7QUFDOUQsdUNBQXVDO0FBRXRDLFVBQVNBLE1BQU0sRUFBRUMsT0FBTSxFQUFFQyxPQUFNO0lBRWhDLFNBQVNDLE9BQU9DLElBQUk7UUFDbEIsSUFBSUMsS0FBSyxJQUFJO1FBRWIsNkJBQTZCO1FBQzdCQSxHQUFHQyxJQUFJLEdBQUc7WUFDUixJQUFJQyxJQUFJRixHQUFHRSxDQUFDLEVBQ1JDLElBQUlILEdBQUdHLENBQUMsRUFBRUMsSUFBSUosR0FBR0ksQ0FBQyxFQUFFQyxHQUFHQztZQUMzQix5QkFBeUI7WUFDekJOLEdBQUdFLENBQUMsR0FBR0EsSUFBSSxJQUFLLGFBQWM7WUFDOUIsd0JBQXdCO1lBQ3hCSSxJQUFJSCxDQUFDLENBQUMsSUFBSyxLQUFNLElBQUk7WUFDckJFLElBQUlGLENBQUMsQ0FBQ0MsSUFBSyxJQUFLLElBQUssSUFBSztZQUMxQkUsS0FBS0EsS0FBSztZQUNWRCxLQUFLQSxLQUFLO1lBQ1ZDLEtBQUtBLE1BQU07WUFDWEQsS0FBS0EsTUFBTTtZQUNYLG9DQUFvQztZQUNwQ0MsSUFBSUgsQ0FBQyxDQUFDQyxFQUFFLEdBQUdFLElBQUlEO1lBQ2ZMLEdBQUdJLENBQUMsR0FBR0E7WUFDUCw2QkFBNkI7WUFDN0IsT0FBTyxJQUFN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R0FBRztZQUN2QixPQUFPQTtRQUNUO1FBQ0FKLEtBQUtLLEtBQUssR0FBR1AsR0FBR25CLElBQUk7UUFDcEJxQixLQUFLTSxLQUFLLEdBQUdOO1FBQ2IsSUFBSUQsT0FBTztZQUNULElBQUlBLE1BQU1sQixDQUFDLEVBQUVXLEtBQUtPLE9BQU9EO1lBQ3pCRSxLQUFLRCxLQUFLLEdBQUc7Z0JBQWEsT0FBT1AsS0FBS00sSUFBSSxDQUFDO1lBQUk7UUFDakQ7UUFDQSxPQUFPRTtJQUNUO0lBRUEsSUFBSTFCLFdBQVVBLFFBQU9pQyxPQUFPLEVBQUU7UUFDNUJqQyxRQUFPaUMsT0FBTyxHQUFHWjtJQUNuQixPQUFPLElBQUlwQix3QkFBQUEsSUFBVUEsd0JBQVUsRUFBRTtRQUMvQkEsbUNBQU87WUFBYSxPQUFPb0I7UUFBTSxDQUFDO0FBQUEsa0dBQUM7SUFDckMsT0FBTztRQUNMLElBQUksQ0FBQ2MsT0FBTyxHQUFHZDtJQUNqQjtBQUVBLEdBQ0UsUUFDQSxLQUFtQixJQUFZckIsUUFDL0Isd0JBQXVDQyxDQUFHLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LW9jZWFuLWZhcm0vLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcz81YTZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIFJpY2hhcmQgQnJlbnQncyBYb3JnZW5zIHhvcjQwOTYgYWxnb3JpdGhtLlxuLy9cbi8vIFRoaXMgZmFzdCBub24tY3J5cHRvZ3JhcGhpYyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyBkZXNpZ25lZCBmb3Jcbi8vIHVzZSBpbiBNb250ZS1DYXJsbyBhbGdvcml0aG1zLiBJdCBjb21iaW5lcyBhIGxvbmctcGVyaW9kIHhvcnNoaWZ0XG4vLyBnZW5lcmF0b3Igd2l0aCBhIFdleWwgZ2VuZXJhdG9yLCBhbmQgaXQgcGFzc2VzIGFsbCBjb21tb24gYmF0dGVyaWVzXG4vLyBvZiBzdGFzdGljaWFsIHRlc3RzIGZvciByYW5kb21uZXNzIHdoaWxlIGNvbnN1bWluZyBvbmx5IGEgZmV3IG5hbm9zZWNvbmRzXG4vLyBmb3IgZWFjaCBwcm5nIGdlbmVyYXRlZC4gIEZvciBiYWNrZ3JvdW5kIG9uIHRoZSBnZW5lcmF0b3IsIHNlZSBCcmVudCdzXG4vLyBwYXBlcjogXCJTb21lIGxvbmctcGVyaW9kIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9ycyB1c2luZyBzaGlmdHMgYW5kIHhvcnMuXCJcbi8vIGh0dHA6Ly9hcnhpdi5vcmcvcGRmLzEwMDQuMzExNXYxLnBkZlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciB4b3I0MDk2ID0gcmVxdWlyZSgneG9yNDA5NicpO1xuLy8gcmFuZG9tID0geG9yNDA5NigxKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkIHdpdGggaW50MzIgb3Igc3RyaW5nLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbSgpLCAwLjE1MjA0MzY0NTA1Mzg1NDcpOyAvLyAoMCwgMSkgcmFuZ2UsIDUzIGJpdHMuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tLmludDMyKCksIDE4MDY1MzQ4OTcpOyAgIC8vIHNpZ25lZCBpbnQzMiwgMzIgYml0cy5cbi8vXG4vLyBGb3Igbm9uemVybyBudW1lcmljIGtleXMsIHRoaXMgaW1wZWxlbWVudGF0aW9uIHByb3ZpZGVzIGEgc2VxdWVuY2Vcbi8vIGlkZW50aWNhbCB0byB0aGF0IGJ5IEJyZW50J3MgeG9yZ2VucyAzIGltcGxlbWVudGFpb24gaW4gQy4gIFRoaXNcbi8vIGltcGxlbWVudGF0aW9uIGFsc28gcHJvdmlkZXMgZm9yIGluaXRhbGl6aW5nIHRoZSBnZW5lcmF0b3Igd2l0aFxuLy8gc3RyaW5nIHNlZWRzLCBvciBmb3Igc2F2aW5nIGFuZCByZXN0b3JpbmcgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXG4vL1xuLy8gT24gQ2hyb21lLCB0aGlzIHBybmcgYmVuY2htYXJrcyBhYm91dCAyLjEgdGltZXMgc2xvd2VyIHRoYW5cbi8vIEphdmFzY3JpcHQncyBidWlsdC1pbiBNYXRoLnJhbmRvbSgpLlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IG1lLncsXG4gICAgICAgIFggPSBtZS5YLCBpID0gbWUuaSwgdCwgdjtcbiAgICAvLyBVcGRhdGUgV2V5bCBnZW5lcmF0b3IuXG4gICAgbWUudyA9IHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgdiBePSB2IDw8IDEzO1xuICAgIHQgXj0gdCA8PCAxNztcbiAgICB2IF49IHYgPj4+IDE1O1xuICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgLy8gVXBkYXRlIFhvciBnZW5lcmF0b3IgYXJyYXkgc3RhdGUuXG4gICAgdiA9IFhbaV0gPSB2IF4gdDtcbiAgICBtZS5pID0gaTtcbiAgICAvLyBSZXN1bHQgaXMgdGhlIGNvbWJpbmF0aW9uLlxuICAgIHJldHVybiAodiArICh3IF4gKHcgPj4+IDE2KSkpIHwgMDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIHQsIHYsIGksIGosIHcsIFggPSBbXSwgbGltaXQgPSAxMjg7XG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIE51bWVyaWMgc2VlZHMgaW5pdGlhbGl6ZSB2LCB3aGljaCBpcyB1c2VkIHRvIGdlbmVyYXRlcyBYLlxuICAgICAgdiA9IHNlZWQ7XG4gICAgICBzZWVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyaW5nIHNlZWRzIGFyZSBtaXhlZCBpbnRvIHYgYW5kIFggb25lIGNoYXJhY3RlciBhdCBhIHRpbWUuXG4gICAgICBzZWVkID0gc2VlZCArICdcXDAnO1xuICAgICAgdiA9IDA7XG4gICAgICBsaW1pdCA9IE1hdGgubWF4KGxpbWl0LCBzZWVkLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgY2lyY3VsYXIgYXJyYXkgYW5kIHdleWwgdmFsdWUuXG4gICAgZm9yIChpID0gMCwgaiA9IC0zMjsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgIC8vIFB1dCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlIGFycmF5LCBhbmQgc2h1ZmZsZSB0aGVtLlxuICAgICAgaWYgKHNlZWQpIHYgXj0gc2VlZC5jaGFyQ29kZUF0KChqICsgMzIpICUgc2VlZC5sZW5ndGgpO1xuICAgICAgLy8gQWZ0ZXIgMzIgc2h1ZmZsZXMsIHRha2UgdiBhcyB0aGUgc3RhcnRpbmcgdyB2YWx1ZS5cbiAgICAgIGlmIChqID09PSAwKSB3ID0gdjtcbiAgICAgIHYgXj0gdiA8PCAxMDtcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB2IF49IHYgPDwgNDtcbiAgICAgIHYgXj0gdiA+Pj4gMTM7XG4gICAgICBpZiAoaiA+PSAwKSB7XG4gICAgICAgIHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDsgICAgIC8vIFdleWwuXG4gICAgICAgIHQgPSAoWFtqICYgMTI3XSBePSAodiArIHcpKTsgIC8vIENvbWJpbmUgeG9yIGFuZCB3ZXlsIHRvIGluaXQgYXJyYXkuXG4gICAgICAgIGkgPSAoMCA9PSB0KSA/IGkgKyAxIDogMDsgICAgIC8vIENvdW50IHplcm9lcy5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhbGwgemVyb2VzOyBtYWtlIHRoZSBrZXkgbm9uemVyby5cbiAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgIFhbKHNlZWQgJiYgc2VlZC5sZW5ndGggfHwgMCkgJiAxMjddID0gLTE7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIDUxMiB0aW1lcyB0byBmdXJ0aGVyIG1peCB0aGUgc3RhdGUgYmVmb3JlIHVzaW5nIGl0LlxuICAgIC8vIEZhY3RvcmluZyB0aGlzIGFzIGEgZnVuY3Rpb24gc2xvd3MgdGhlIG1haW4gZ2VuZXJhdG9yLCBzbyBpdCBpcyBqdXN0XG4gICAgLy8gdW5yb2xsZWQgaGVyZS4gIFRoZSB3ZXlsIGdlbmVyYXRvciBpcyBub3QgYWR2YW5jZWQgd2hpbGUgd2FybWluZyB1cC5cbiAgICBpID0gMTI3O1xuICAgIGZvciAoaiA9IDQgKiAxMjg7IGogPiAwOyAtLWopIHtcbiAgICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgICAgdiBePSB2IDw8IDEzO1xuICAgICAgdCBePSB0IDw8IDE3O1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgICBYW2ldID0gdiBeIHQ7XG4gICAgfVxuICAgIC8vIFN0b3Jpbmcgc3RhdGUgYXMgb2JqZWN0IG1lbWJlcnMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMuXG4gICAgbWUudyA9IHc7XG4gICAgbWUuWCA9IFg7XG4gICAgbWUuaSA9IGk7XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC53ID0gZi53O1xuICB0LlggPSBmLlguc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5YKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yNDA5NiA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cgb2JqZWN0IG9yIGdsb2JhbFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwibW9kdWxlIiwiZGVmaW5lIiwiWG9yR2VuIiwic2VlZCIsIm1lIiwibmV4dCIsInciLCJYIiwiaSIsInQiLCJ2IiwiaW5pdCIsImoiLCJsaW1pdCIsIk1hdGgiLCJtYXgiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiY29weSIsImYiLCJzbGljZSIsImltcGwiLCJvcHRzIiwiRGF0ZSIsInhnIiwic3RhdGUiLCJwcm5nIiwiZG91YmxlIiwidG9wIiwiYm90IiwicmVzdWx0IiwiaW50MzIiLCJxdWljayIsImV4cG9ydHMiLCJhbWQiLCJ4b3I0MDk2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/xor4096.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/xorshift7.js":
/*!**************************************************!*\
  !*** ./node_modules/seedrandom/lib/xorshift7.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n// A Javascript implementaion of the \"xorshift7\" algorithm by\n// François Panneton and Pierre L'ecuyer:\n// \"On the Xorgshift Random Number Generators\"\n// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf\n(function(global, module1, define1) {\n    function XorGen(seed) {\n        var me = this;\n        // Set up generator function.\n        me.next = function() {\n            // Update xor generator.\n            var X = me.x, i = me.i, t, v, w;\n            t = X[i];\n            t ^= t >>> 7;\n            v = t ^ t << 24;\n            t = X[i + 1 & 7];\n            v ^= t ^ t >>> 10;\n            t = X[i + 3 & 7];\n            v ^= t ^ t >>> 3;\n            t = X[i + 4 & 7];\n            v ^= t ^ t << 7;\n            t = X[i + 7 & 7];\n            t = t ^ t << 13;\n            v ^= t ^ t << 9;\n            X[i] = v;\n            me.i = i + 1 & 7;\n            return v;\n        };\n        function init(me, seed) {\n            var j, w, X = [];\n            if (seed === (seed | 0)) {\n                // Seed state array using a 32-bit integer.\n                w = X[0] = seed;\n            } else {\n                // Seed state using a string.\n                seed = \"\" + seed;\n                for(j = 0; j < seed.length; ++j){\n                    X[j & 7] = X[j & 7] << 15 ^ seed.charCodeAt(j) + X[j + 1 & 7] << 13;\n                }\n            }\n            // Enforce an array length of 8, not all zeroes.\n            while(X.length < 8)X.push(0);\n            for(j = 0; j < 8 && X[j] === 0; ++j);\n            if (j == 8) w = X[7] = -1;\n            else w = X[j];\n            me.x = X;\n            me.i = 0;\n            // Discard an initial 256 values.\n            for(j = 256; j > 0; --j){\n                me.next();\n            }\n        }\n        init(me, seed);\n    }\n    function copy(f, t) {\n        t.x = f.x.slice();\n        t.i = f.i;\n        return t;\n    }\n    function impl(seed, opts) {\n        if (seed == null) seed = +new Date;\n        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {\n            return (xg.next() >>> 0) / 0x100000000;\n        };\n        prng.double = function() {\n            do {\n                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);\n            }while (result === 0);\n            return result;\n        };\n        prng.int32 = xg.next;\n        prng.quick = prng;\n        if (state) {\n            if (state.x) copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.xorshift7 = impl;\n    }\n})(void 0,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsNkRBQTZEO0FBQzdELHlDQUF5QztBQUN6Qyw4Q0FBOEM7QUFDOUMsMEVBQTBFO0FBRXpFLFVBQVNBLE1BQU0sRUFBRUMsT0FBTSxFQUFFQyxPQUFNO0lBRWhDLFNBQVNDLE9BQU9DLElBQUk7UUFDbEIsSUFBSUMsS0FBSyxJQUFJO1FBRWIsNkJBQTZCO1FBQzdCQSxHQUFHQyxJQUFJLEdBQUc7WUFDUix3QkFBd0I7WUFDeEIsSUFBSUMsSUFBSUYsR0FBR0csQ0FBQyxFQUFFQyxJQUFJSixHQUFHSSxDQUFDLEVBQUVDLEdBQUdDLEdBQUdDO1lBQzlCRixJQUFJSCxDQUFDLENBQUNFLEVBQUU7WUFBRUMsS0FBTUEsTUFBTTtZQUFJQyxJQUFJRCxJQUFLQSxLQUFLO1lBQ3hDQSxJQUFJSCxDQUFDLENBQUMsSUFBSyxJQUFLLEVBQUU7WUFBRUksS0FBS0QsSUFBS0EsTUFBTTtZQUNwQ0EsSUFBSUgsQ0FBQyxDQUFDLElBQUssSUFBSyxFQUFFO1lBQUVJLEtBQUtELElBQUtBLE1BQU07WUFDcENBLElBQUlILENBQUMsQ0FBQyxJQUFLLElBQUssRUFBRTtZQUFFSSxLQUFLRCxJQUFLQSxLQUFLO1lBQ25DQSxJQUFJSCxDQUFDLENBQUMsSUFBSyxJQUFLLEVBQUU7WUFBRUcsSUFBSUEsSUFBS0EsS0FBSztZQUFLQyxLQUFLRCxJQUFLQSxLQUFLO1lBQ3RESCxDQUFDLENBQUNFLEVBQUUsR0FBR0U7WUFDUE4sR0FBR0ksQ0FBQyxHQUFHLElBQUssSUFBSztZQUNqQixPQUFPRTtRQUNUO1FBRUEsU0FBU0UsS0FBS1IsRUFBRSxFQUFFRCxJQUFJO1lBQ3BCLElBQUlVLEdBQUdGLEdBQUdMLElBQUksRUFBRTtZQUVoQixJQUFJSCxTQUFVQSxDQUFBQSxPQUFPLElBQUk7Z0JBQ3ZCLDJDQUEyQztnQkFDM0NRLElBQUlMLENBQUMsQ0FBQyxFQUFFLEdBQUdIO1lBQ2IsT0FBTztnQkFDTCw2QkFBNkI7Z0JBQzdCQSxPQUFPLEtBQUtBO2dCQUNaLElBQUtVLElBQUksR0FBR0EsSUFBSVYsS0FBS1csTUFBTSxFQUFFLEVBQUVELEVBQUc7b0JBQ2hDUCxDQUFDLENBQUNPLElBQUksRUFBRSxHQUFHLENBQUUsQ0FBQ0EsSUFBSSxFQUFFLElBQUksS0FDbkJWLEtBQUtZLFVBQVUsQ0FBQ0YsS0FBS1AsQ0FBQyxDQUFDLElBQUssSUFBSyxFQUFFLElBQUk7Z0JBQzlDO1lBQ0Y7WUFDQSxnREFBZ0Q7WUFDaEQsTUFBT0EsRUFBRVEsTUFBTSxHQUFHLEVBQUdSLEVBQUVVLElBQUksQ0FBQztZQUM1QixJQUFLSCxJQUFJLEdBQUdBLElBQUksS0FBS1AsQ0FBQyxDQUFDTyxFQUFFLEtBQUssR0FBRyxFQUFFQTtZQUNuQyxJQUFJQSxLQUFLLEdBQUdGLElBQUlMLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztpQkFBUUssSUFBSUwsQ0FBQyxDQUFDTyxFQUFFO1lBRXhDVCxHQUFHRyxDQUFDLEdBQUdEO1lBQ1BGLEdBQUdJLENBQUMsR0FBRztZQUVQLGlDQUFpQztZQUNqQyxJQUFLSyxJQUFJLEtBQUtBLElBQUksR0FBRyxFQUFFQSxFQUFHO2dCQUN4QlQsR0FBR0MsSUFBSTtZQUNUO1FBQ0Y7UUFFQU8sS0FBS1IsSUFBSUQ7SUFDWDtJQUVBLFNBQVNjLEtBQUtDLENBQUMsRUFBRVQsQ0FBQztRQUNoQkEsRUFBRUYsQ0FBQyxHQUFHVyxFQUFFWCxDQUFDLENBQUNZLEtBQUs7UUFDZlYsRUFBRUQsQ0FBQyxHQUFHVSxFQUFFVixDQUFDO1FBQ1QsT0FBT0M7SUFDVDtJQUVBLFNBQVNXLEtBQUtqQixJQUFJLEVBQUVrQixJQUFJO1FBQ3RCLElBQUlsQixRQUFRLE1BQU1BLE9BQU8sQ0FBRSxJQUFJbUI7UUFDL0IsSUFBSUMsS0FBSyxJQUFJckIsT0FBT0MsT0FDaEJxQixRQUFRSCxRQUFRQSxLQUFLRyxLQUFLLEVBQzFCQyxPQUFPO1lBQWEsT0FBTyxDQUFDRixHQUFHbEIsSUFBSSxPQUFPLEtBQUs7UUFBYTtRQUNoRW9CLEtBQUtDLE1BQU0sR0FBRztZQUNaLEdBQUc7Z0JBQ0QsSUFBSUMsTUFBTUosR0FBR2xCLElBQUksT0FBTyxJQUNwQnVCLE1BQU0sQ0FBQ0wsR0FBR2xCLElBQUksT0FBTyxLQUFLLGFBQzFCd0IsU0FBUyxDQUFDRixNQUFNQyxHQUFFLElBQU0sTUFBSyxFQUFDO1lBQ3BDLFFBQVNDLFdBQVcsR0FBRztZQUN2QixPQUFPQTtRQUNUO1FBQ0FKLEtBQUtLLEtBQUssR0FBR1AsR0FBR2xCLElBQUk7UUFDcEJvQixLQUFLTSxLQUFLLEdBQUdOO1FBQ2IsSUFBSUQsT0FBTztZQUNULElBQUlBLE1BQU1qQixDQUFDLEVBQUVVLEtBQUtPLE9BQU9EO1lBQ3pCRSxLQUFLRCxLQUFLLEdBQUc7Z0JBQWEsT0FBT1AsS0FBS00sSUFBSSxDQUFDO1lBQUk7UUFDakQ7UUFDQSxPQUFPRTtJQUNUO0lBRUEsSUFBSXpCLFdBQVVBLFFBQU9nQyxPQUFPLEVBQUU7UUFDNUJoQyxRQUFPZ0MsT0FBTyxHQUFHWjtJQUNuQixPQUFPLElBQUluQix3QkFBQUEsSUFBVUEsd0JBQVUsRUFBRTtRQUMvQkEsbUNBQU87WUFBYSxPQUFPbUI7UUFBTSxDQUFDO0FBQUEsa0dBQUM7SUFDckMsT0FBTztRQUNMLElBQUksQ0FBQ2MsU0FBUyxHQUFHZDtJQUNuQjtBQUVBLEdBQ0UsUUFDQSxLQUFtQixJQUFZcEIsUUFDL0Isd0JBQXVDQyxDQUFHLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LW9jZWFuLWZhcm0vLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzPzdlYmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yc2hpZnQ3XCIgYWxnb3JpdGhtIGJ5XG4vLyBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllcjpcbi8vIFwiT24gdGhlIFhvcmdzaGlmdCBSYW5kb20gTnVtYmVyIEdlbmVyYXRvcnNcIlxuLy8gaHR0cDovL3NhbHVjLmVuZ3IudWNvbm4uZWR1L3JlZnMvY3J5cHRvL3JuZy9wYW5uZXRvbjA1b250aGV4b3JzaGlmdC5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVXBkYXRlIHhvciBnZW5lcmF0b3IuXG4gICAgdmFyIFggPSBtZS54LCBpID0gbWUuaSwgdCwgdiwgdztcbiAgICB0ID0gWFtpXTsgdCBePSAodCA+Pj4gNyk7IHYgPSB0IF4gKHQgPDwgMjQpO1xuICAgIHQgPSBYWyhpICsgMSkgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDEwKTtcbiAgICB0ID0gWFsoaSArIDMpICYgN107IHYgXj0gdCBeICh0ID4+PiAzKTtcbiAgICB0ID0gWFsoaSArIDQpICYgN107IHYgXj0gdCBeICh0IDw8IDcpO1xuICAgIHQgPSBYWyhpICsgNykgJiA3XTsgdCA9IHQgXiAodCA8PCAxMyk7IHYgXj0gdCBeICh0IDw8IDkpO1xuICAgIFhbaV0gPSB2O1xuICAgIG1lLmkgPSAoaSArIDEpICYgNztcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIGosIHcsIFggPSBbXTtcblxuICAgIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIGFycmF5IHVzaW5nIGEgMzItYml0IGludGVnZXIuXG4gICAgICB3ID0gWFswXSA9IHNlZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgdXNpbmcgYSBzdHJpbmcuXG4gICAgICBzZWVkID0gJycgKyBzZWVkO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHNlZWQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgWFtqICYgN10gPSAoWFtqICYgN10gPDwgMTUpIF5cbiAgICAgICAgICAgIChzZWVkLmNoYXJDb2RlQXQoaikgKyBYWyhqICsgMSkgJiA3XSA8PCAxMyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVuZm9yY2UgYW4gYXJyYXkgbGVuZ3RoIG9mIDgsIG5vdCBhbGwgemVyb2VzLlxuICAgIHdoaWxlIChYLmxlbmd0aCA8IDgpIFgucHVzaCgwKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgOCAmJiBYW2pdID09PSAwOyArK2opO1xuICAgIGlmIChqID09IDgpIHcgPSBYWzddID0gLTE7IGVsc2UgdyA9IFhbal07XG5cbiAgICBtZS54ID0gWDtcbiAgICBtZS5pID0gMDtcblxuICAgIC8vIERpc2NhcmQgYW4gaW5pdGlhbCAyNTYgdmFsdWVzLlxuICAgIGZvciAoaiA9IDI1NjsgaiA+IDA7IC0taikge1xuICAgICAgbWUubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54LnNsaWNlKCk7XG4gIHQuaSA9IGYuaTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLngpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3JzaGlmdDcgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwibW9kdWxlIiwiZGVmaW5lIiwiWG9yR2VuIiwic2VlZCIsIm1lIiwibmV4dCIsIlgiLCJ4IiwiaSIsInQiLCJ2IiwidyIsImluaXQiLCJqIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsInB1c2giLCJjb3B5IiwiZiIsInNsaWNlIiwiaW1wbCIsIm9wdHMiLCJEYXRlIiwieGciLCJzdGF0ZSIsInBybmciLCJkb3VibGUiLCJ0b3AiLCJib3QiLCJyZXN1bHQiLCJpbnQzMiIsInF1aWNrIiwiZXhwb3J0cyIsImFtZCIsInhvcnNoaWZ0NyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/xorshift7.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/xorwow.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xorwow.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n// A Javascript implementaion of the \"xorwow\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n(function(global, module1, define1) {\n    function XorGen(seed) {\n        var me = this, strseed = \"\";\n        // Set up generator function.\n        me.next = function() {\n            var t = me.x ^ me.x >>> 2;\n            me.x = me.y;\n            me.y = me.z;\n            me.z = me.w;\n            me.w = me.v;\n            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;\n        };\n        me.x = 0;\n        me.y = 0;\n        me.z = 0;\n        me.w = 0;\n        me.v = 0;\n        if (seed === (seed | 0)) {\n            // Integer seed.\n            me.x = seed;\n        } else {\n            // String seed.\n            strseed += seed;\n        }\n        // Mix in string seed, then discard an initial batch of 64 values.\n        for(var k = 0; k < strseed.length + 64; k++){\n            me.x ^= strseed.charCodeAt(k) | 0;\n            if (k == strseed.length) {\n                me.d = me.x << 10 ^ me.x >>> 4;\n            }\n            me.next();\n        }\n    }\n    function copy(f, t) {\n        t.x = f.x;\n        t.y = f.y;\n        t.z = f.z;\n        t.w = f.w;\n        t.v = f.v;\n        t.d = f.d;\n        return t;\n    }\n    function impl(seed, opts) {\n        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {\n            return (xg.next() >>> 0) / 0x100000000;\n        };\n        prng.double = function() {\n            do {\n                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);\n            }while (result === 0);\n            return result;\n        };\n        prng.int32 = xg.next;\n        prng.quick = prng;\n        if (state) {\n            if (typeof state == \"object\") copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.xorwow = impl;\n    }\n})(void 0,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yd293LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsK0RBQStEO0FBQy9ELGdFQUFnRTtBQUUvRCxVQUFTQSxNQUFNLEVBQUVDLE9BQU0sRUFBRUMsT0FBTTtJQUVoQyxTQUFTQyxPQUFPQyxJQUFJO1FBQ2xCLElBQUlDLEtBQUssSUFBSSxFQUFFQyxVQUFVO1FBRXpCLDZCQUE2QjtRQUM3QkQsR0FBR0UsSUFBSSxHQUFHO1lBQ1IsSUFBSUMsSUFBS0gsR0FBR0ksQ0FBQyxHQUFJSixHQUFHSSxDQUFDLEtBQUs7WUFDMUJKLEdBQUdJLENBQUMsR0FBR0osR0FBR0ssQ0FBQztZQUFFTCxHQUFHSyxDQUFDLEdBQUdMLEdBQUdNLENBQUM7WUFBRU4sR0FBR00sQ0FBQyxHQUFHTixHQUFHTyxDQUFDO1lBQUVQLEdBQUdPLENBQUMsR0FBR1AsR0FBR1EsQ0FBQztZQUNsRCxPQUFPLENBQUNSLEdBQUdTLENBQUMsR0FBSVQsR0FBR1MsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxJQUM3QlQsQ0FBQUEsR0FBR1EsQ0FBQyxHQUFHLEdBQUlBLENBQUMsR0FBSVIsR0FBR1EsQ0FBQyxJQUFJLElBQU9MLENBQUFBLElBQUtBLEtBQUssQ0FBQyxDQUFDLElBQUs7UUFDdEQ7UUFFQUgsR0FBR0ksQ0FBQyxHQUFHO1FBQ1BKLEdBQUdLLENBQUMsR0FBRztRQUNQTCxHQUFHTSxDQUFDLEdBQUc7UUFDUE4sR0FBR08sQ0FBQyxHQUFHO1FBQ1BQLEdBQUdRLENBQUMsR0FBRztRQUVQLElBQUlULFNBQVVBLENBQUFBLE9BQU8sSUFBSTtZQUN2QixnQkFBZ0I7WUFDaEJDLEdBQUdJLENBQUMsR0FBR0w7UUFDVCxPQUFPO1lBQ0wsZUFBZTtZQUNmRSxXQUFXRjtRQUNiO1FBRUEsa0VBQWtFO1FBQ2xFLElBQUssSUFBSVcsSUFBSSxHQUFHQSxJQUFJVCxRQUFRVSxNQUFNLEdBQUcsSUFBSUQsSUFBSztZQUM1Q1YsR0FBR0ksQ0FBQyxJQUFJSCxRQUFRVyxVQUFVLENBQUNGLEtBQUs7WUFDaEMsSUFBSUEsS0FBS1QsUUFBUVUsTUFBTSxFQUFFO2dCQUN2QlgsR0FBR1MsQ0FBQyxHQUFHVCxHQUFHSSxDQUFDLElBQUksS0FBS0osR0FBR0ksQ0FBQyxLQUFLO1lBQy9CO1lBQ0FKLEdBQUdFLElBQUk7UUFDVDtJQUNGO0lBRUEsU0FBU1csS0FBS0MsQ0FBQyxFQUFFWCxDQUFDO1FBQ2hCQSxFQUFFQyxDQUFDLEdBQUdVLEVBQUVWLENBQUM7UUFDVEQsRUFBRUUsQ0FBQyxHQUFHUyxFQUFFVCxDQUFDO1FBQ1RGLEVBQUVHLENBQUMsR0FBR1EsRUFBRVIsQ0FBQztRQUNUSCxFQUFFSSxDQUFDLEdBQUdPLEVBQUVQLENBQUM7UUFDVEosRUFBRUssQ0FBQyxHQUFHTSxFQUFFTixDQUFDO1FBQ1RMLEVBQUVNLENBQUMsR0FBR0ssRUFBRUwsQ0FBQztRQUNULE9BQU9OO0lBQ1Q7SUFFQSxTQUFTWSxLQUFLaEIsSUFBSSxFQUFFaUIsSUFBSTtRQUN0QixJQUFJQyxLQUFLLElBQUluQixPQUFPQyxPQUNoQm1CLFFBQVFGLFFBQVFBLEtBQUtFLEtBQUssRUFDMUJDLE9BQU87WUFBYSxPQUFPLENBQUNGLEdBQUdmLElBQUksT0FBTyxLQUFLO1FBQWE7UUFDaEVpQixLQUFLQyxNQUFNLEdBQUc7WUFDWixHQUFHO2dCQUNELElBQUlDLE1BQU1KLEdBQUdmLElBQUksT0FBTyxJQUNwQm9CLE1BQU0sQ0FBQ0wsR0FBR2YsSUFBSSxPQUFPLEtBQUssYUFDMUJxQixTQUFTLENBQUNGLE1BQU1DLEdBQUUsSUFBTSxNQUFLLEVBQUM7WUFDcEMsUUFBU0MsV0FBVyxHQUFHO1lBQ3ZCLE9BQU9BO1FBQ1Q7UUFDQUosS0FBS0ssS0FBSyxHQUFHUCxHQUFHZixJQUFJO1FBQ3BCaUIsS0FBS00sS0FBSyxHQUFHTjtRQUNiLElBQUlELE9BQU87WUFDVCxJQUFJLE9BQU9BLFNBQVUsVUFBVUwsS0FBS0ssT0FBT0Q7WUFDM0NFLEtBQUtELEtBQUssR0FBRztnQkFBYSxPQUFPTCxLQUFLSSxJQUFJLENBQUM7WUFBSTtRQUNqRDtRQUNBLE9BQU9FO0lBQ1Q7SUFFQSxJQUFJdkIsV0FBVUEsUUFBTzhCLE9BQU8sRUFBRTtRQUM1QjlCLFFBQU84QixPQUFPLEdBQUdYO0lBQ25CLE9BQU8sSUFBSWxCLHdCQUFBQSxJQUFVQSx3QkFBVSxFQUFFO1FBQy9CQSxtQ0FBTztZQUFhLE9BQU9rQjtRQUFNLENBQUM7QUFBQSxrR0FBQztJQUNyQyxPQUFPO1FBQ0wsSUFBSSxDQUFDYSxNQUFNLEdBQUdiO0lBQ2hCO0FBRUEsR0FDRSxRQUNBLEtBQW1CLElBQVluQixRQUMvQix3QkFBdUNDLENBQUcsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtb2NlYW4tZmFybS8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3J3b3cuanM/ZWMxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3J3b3dcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gR2VvcmdlIE1hcnNhZ2xpYS4gIFNlZSBodHRwOi8vd3d3LmpzdGF0c29mdC5vcmcvdjA4L2kxNC9wYXBlclxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gKG1lLnggXiAobWUueCA+Pj4gMikpO1xuICAgIG1lLnggPSBtZS55OyBtZS55ID0gbWUuejsgbWUueiA9IG1lLnc7IG1lLncgPSBtZS52O1xuICAgIHJldHVybiAobWUuZCA9IChtZS5kICsgMzYyNDM3IHwgMCkpICtcbiAgICAgICAobWUudiA9IChtZS52IF4gKG1lLnYgPDwgNCkpIF4gKHQgXiAodCA8PCAxKSkpIHwgMDtcbiAgfTtcblxuICBtZS54ID0gMDtcbiAgbWUueSA9IDA7XG4gIG1lLnogPSAwO1xuICBtZS53ID0gMDtcbiAgbWUudiA9IDA7XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIGlmIChrID09IHN0cnNlZWQubGVuZ3RoKSB7XG4gICAgICBtZS5kID0gbWUueCA8PCAxMCBeIG1lLnggPj4+IDQ7XG4gICAgfVxuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICB0LnYgPSBmLnY7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yd293ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwibW9kdWxlIiwiZGVmaW5lIiwiWG9yR2VuIiwic2VlZCIsIm1lIiwic3Ryc2VlZCIsIm5leHQiLCJ0IiwieCIsInkiLCJ6IiwidyIsInYiLCJkIiwiayIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjb3B5IiwiZiIsImltcGwiLCJvcHRzIiwieGciLCJzdGF0ZSIsInBybmciLCJkb3VibGUiLCJ0b3AiLCJib3QiLCJyZXN1bHQiLCJpbnQzMiIsInF1aWNrIiwiZXhwb3J0cyIsImFtZCIsInhvcndvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/xorwow.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/seedrandom.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/seedrandom.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n/*\nCopyright 2019 David Bau.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/ (function(global, pool, math) {\n    //\n    // The following constants are related to IEEE 754 limits.\n    //\n    var width = 256, chunks = 6, digits = 52, rngname = \"random\", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto; // node.js crypto module, initialized at the bottom.\n    //\n    // seedrandom()\n    // This is the seedrandom function described above.\n    //\n    function seedrandom(seed, options, callback) {\n        var key = [];\n        options = options == true ? {\n            entropy: true\n        } : options || {};\n        // Flatten the seed string or build one from local entropy if needed.\n        var shortseed = mixkey(flatten(options.entropy ? [\n            seed,\n            tostring(pool)\n        ] : seed == null ? autoseed() : seed, 3), key);\n        // Use the seed to initialize an ARC4 generator.\n        var arc4 = new ARC4(key);\n        // This function returns a random double in [0, 1) that contains\n        // randomness in every bit of the mantissa of the IEEE 754 value.\n        var prng = function() {\n            var n = arc4.g(chunks), d = startdenom, x = 0; //   and no 'extra last byte'.\n            while(n < significance){\n                n = (n + x) * width; //   shifting numerator and\n                d *= width; //   denominator and generating a\n                x = arc4.g(1); //   new least-significant-byte.\n            }\n            while(n >= overflow){\n                n /= 2; //   last byte, shift everything\n                d /= 2; //   right using integer math until\n                x >>>= 1; //   we have exactly the desired bits.\n            }\n            return (n + x) / d; // Form the number within [0, 1).\n        };\n        prng.int32 = function() {\n            return arc4.g(4) | 0;\n        };\n        prng.quick = function() {\n            return arc4.g(4) / 0x100000000;\n        };\n        prng.double = prng;\n        // Mix the randomness into accumulated entropy.\n        mixkey(tostring(arc4.S), pool);\n        // Calling convention: what to return as a function of prng, seed, is_math.\n        return (options.pass || callback || function(prng, seed, is_math_call, state) {\n            if (state) {\n                // Load the arc4 state from the given state if it has an S array.\n                if (state.S) {\n                    copy(state, arc4);\n                }\n                // Only provide the .state method if requested via options.state.\n                prng.state = function() {\n                    return copy(arc4, {});\n                };\n            }\n            // If called as a method of Math (Math.seedrandom()), mutate\n            // Math.random because that is how seedrandom.js has worked since v1.0.\n            if (is_math_call) {\n                math[rngname] = prng;\n                return seed;\n            } else return prng;\n        })(prng, shortseed, \"global\" in options ? options.global : this == math, options.state);\n    }\n    //\n    // ARC4\n    //\n    // An ARC4 implementation.  The constructor takes a key in the form of\n    // an array of at most (width) integers that should be 0 <= x < (width).\n    //\n    // The g(count) method returns a pseudorandom integer that concatenates\n    // the next (count) outputs from ARC4.  Its return value is a number x\n    // that is in the range 0 <= x < (width ^ count).\n    //\n    function ARC4(key) {\n        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];\n        // The empty key [] is treated as [0].\n        if (!keylen) {\n            key = [\n                keylen++\n            ];\n        }\n        // Set up S using the standard key scheduling algorithm.\n        while(i < width){\n            s[i] = i++;\n        }\n        for(i = 0; i < width; i++){\n            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n            s[j] = t;\n        }\n        // The \"g\" method returns the next (count) outputs as one number.\n        (me.g = function(count) {\n            // Using instance members instead of closure state nearly doubles speed.\n            var t, r = 0, i = me.i, j = me.j, s = me.S;\n            while(count--){\n                t = s[i = mask & i + 1];\n                r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n            }\n            me.i = i;\n            me.j = j;\n            return r;\n        // For robust unpredictability, the function call below automatically\n        // discards an initial batch of values.  This is called RC4-drop[256].\n        // See http://google.com/search?q=rsa+fluhrer+response&btnI\n        })(width);\n    }\n    //\n    // copy()\n    // Copies internal state of ARC4 to or from a plain object.\n    //\n    function copy(f, t) {\n        t.i = f.i;\n        t.j = f.j;\n        t.S = f.S.slice();\n        return t;\n    }\n    ;\n    //\n    // flatten()\n    // Converts an object tree to nested arrays of strings.\n    //\n    function flatten(obj, depth) {\n        var result = [], typ = typeof obj, prop;\n        if (depth && typ == \"object\") {\n            for(prop in obj){\n                try {\n                    result.push(flatten(obj[prop], depth - 1));\n                } catch (e) {}\n            }\n        }\n        return result.length ? result : typ == \"string\" ? obj : obj + \"\\x00\";\n    }\n    //\n    // mixkey()\n    // Mixes a string seed into a key that is an array of integers, and\n    // returns a shortened string seed that is equivalent to the result key.\n    //\n    function mixkey(seed, key) {\n        var stringseed = seed + \"\", smear, j = 0;\n        while(j < stringseed.length){\n            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n        }\n        return tostring(key);\n    }\n    //\n    // autoseed()\n    // Returns an object for autoseeding, using window.crypto and Node crypto\n    // module if available.\n    //\n    function autoseed() {\n        try {\n            var out;\n            if (nodecrypto && (out = nodecrypto.randomBytes)) {\n                // The use of 'out' to remember randomBytes makes tight minified code.\n                out = out(width);\n            } else {\n                out = new Uint8Array(width);\n                (global.crypto || global.msCrypto).getRandomValues(out);\n            }\n            return tostring(out);\n        } catch (e) {\n            var browser = global.navigator, plugins = browser && browser.plugins;\n            return [\n                +new Date,\n                global,\n                plugins,\n                global.screen,\n                tostring(pool)\n            ];\n        }\n    }\n    //\n    // tostring()\n    // Converts an array of charcodes to a string\n    //\n    function tostring(a) {\n        return String.fromCharCode.apply(0, a);\n    }\n    //\n    // When seedrandom.js is loaded, we immediately mix a few bits\n    // from the built-in RNG into the entropy pool.  Because we do\n    // not want to interfere with deterministic PRNG state later,\n    // seedrandom will not call math.random on its own again after\n    // initialization.\n    //\n    mixkey(math.random(), pool);\n    //\n    // Nodejs and AMD support: export the implementation as a module using\n    // either convention.\n    //\n    if ( true && module.exports) {\n        module.exports = seedrandom;\n        // When in node.js, try using crypto package for autoseeding.\n        try {\n            nodecrypto = __webpack_require__(/*! crypto */ \"crypto\");\n        } catch (ex) {}\n    } else if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return seedrandom;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n// End anonymous scope, and pass initial values.\n})(// global: `self` in browsers (including strict mode and web workers),\n// otherwise `this` in Node and other environments\ntypeof self !== \"undefined\" ? self : void 0, [], Math // math: package containing random, pow, and seedrandom\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9zZWVkcmFuZG9tLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQSxHQUVDLFVBQVVBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxJQUFJO0lBQzdCLEVBQUU7SUFDRiwwREFBMEQ7SUFDMUQsRUFBRTtJQUVGLElBQUlDLFFBQVEsS0FDUkMsU0FBUyxHQUNUQyxTQUFTLElBQ1RDLFVBQVUsVUFDVkMsYUFBYUwsS0FBS00sR0FBRyxDQUFDTCxPQUFPQyxTQUM3QkssZUFBZVAsS0FBS00sR0FBRyxDQUFDLEdBQUdILFNBQzNCSyxXQUFXRCxlQUFlLEdBQzFCRSxPQUFPUixRQUFRLEdBQ2ZTLFlBQW9CLG9EQUFvRDtJQUU1RSxFQUFFO0lBQ0YsZUFBZTtJQUNmLG1EQUFtRDtJQUNuRCxFQUFFO0lBQ0YsU0FBU0MsV0FBV0MsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7UUFDekMsSUFBSUMsTUFBTSxFQUFFO1FBQ1pGLFVBQVUsV0FBWSxPQUFRO1lBQUVHLFNBQVM7UUFBSyxJQUFLSCxXQUFXLENBQUM7UUFFL0QscUVBQXFFO1FBQ3JFLElBQUlJLFlBQVlDLE9BQU9DLFFBQ3JCTixRQUFRRyxPQUFPLEdBQUc7WUFBQ0o7WUFBTVEsU0FBU3JCO1NBQU0sR0FDeEMsUUFBUyxPQUFRc0IsYUFBYVQsTUFBTSxJQUFJRztRQUUxQyxnREFBZ0Q7UUFDaEQsSUFBSU8sT0FBTyxJQUFJQyxLQUFLUjtRQUVwQixnRUFBZ0U7UUFDaEUsaUVBQWlFO1FBQ2pFLElBQUlTLE9BQU87WUFDVCxJQUFJQyxJQUFJSCxLQUFLSSxDQUFDLENBQUN4QixTQUNYeUIsSUFBSXRCLFlBQ0p1QixJQUFJLEdBQTRCLDhCQUE4QjtZQUNsRSxNQUFPSCxJQUFJbEIsYUFBYztnQkFDdkJrQixJQUFJLENBQUNBLElBQUlHLENBQUFBLElBQUszQixPQUFvQiwyQkFBMkI7Z0JBQzdEMEIsS0FBSzFCLE9BQTZCLGlD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S0FBbUIsSUFBWTJFLE9BQU9DLE9BQU8sRUFBRTtRQUNqREQsT0FBT0MsT0FBTyxHQUFHaEU7UUFDakIsNkRBQTZEO1FBQzdELElBQUk7WUFDRkQsYUFBYWtFLG1CQUFPQSxDQUFDO1FBQ3ZCLEVBQUUsT0FBT0MsSUFBSSxDQUFDO0lBQ2hCLE9BQU8sSUFBSSxJQUEyQyxFQUFFO1FBQ3REQyxtQ0FBTztZQUFhLE9BQU9uRTtRQUFZLENBQUM7QUFBQSxrR0FBQztJQUMzQyxPQUFPLEVBR047QUFHRCxnREFBZ0Q7QUFDaEQsR0FHRSxzRUFGc0U7QUFDdEUsa0RBQWtEO0FBQ2pELE9BQU9xRSxTQUFTLGNBQWVBLE9BQU8sUUFDdkMsRUFBRSxFQUNGQyxLQUFRLHVEQUF1RCIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LW9jZWFuLWZhcm0vLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9zZWVkcmFuZG9tLmpzPzY0NDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDE5IERhdmlkIEJhdS5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5JTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcblRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5TT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIHBvb2wsIG1hdGgpIHtcbi8vXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXG4vL1xuXG52YXIgd2lkdGggPSAyNTYsICAgICAgICAvLyBlYWNoIFJDNCBvdXRwdXQgaXMgMCA8PSB4IDwgMjU2XG4gICAgY2h1bmtzID0gNiwgICAgICAgICAvLyBhdCBsZWFzdCBzaXggUkM0IG91dHB1dHMgZm9yIGVhY2ggZG91YmxlXG4gICAgZGlnaXRzID0gNTIsICAgICAgICAvLyB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICAgcm5nbmFtZSA9ICdyYW5kb20nLCAvLyBybmduYW1lOiBuYW1lIGZvciBNYXRoLnJhbmRvbSBhbmQgTWF0aC5zZWVkcmFuZG9tXG4gICAgc3RhcnRkZW5vbSA9IG1hdGgucG93KHdpZHRoLCBjaHVua3MpLFxuICAgIHNpZ25pZmljYW5jZSA9IG1hdGgucG93KDIsIGRpZ2l0cyksXG4gICAgb3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyLFxuICAgIG1hc2sgPSB3aWR0aCAtIDEsXG4gICAgbm9kZWNyeXB0bzsgICAgICAgICAvLyBub2RlLmpzIGNyeXB0byBtb2R1bGUsIGluaXRpYWxpemVkIGF0IHRoZSBib3R0b20uXG5cbi8vXG4vLyBzZWVkcmFuZG9tKClcbi8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxuLy9cbmZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGtleSA9IFtdO1xuICBvcHRpb25zID0gKG9wdGlvbnMgPT0gdHJ1ZSkgPyB7IGVudHJvcHk6IHRydWUgfSA6IChvcHRpb25zIHx8IHt9KTtcblxuICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cbiAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKFxuICAgIG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOlxuICAgIChzZWVkID09IG51bGwpID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpO1xuXG4gIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuICB2YXIgcHJuZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgICAgICBkID0gc3RhcnRkZW5vbSwgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgICAgIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XG4gICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICB9XG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xuICAgICAgZCAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICB9XG4gICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gIH07XG5cbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIHwgMDsgfVxuICBwcm5nLnF1aWNrID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDsgfVxuICBwcm5nLmRvdWJsZSA9IHBybmc7XG5cbiAgLy8gTWl4IHRoZSByYW5kb21uZXNzIGludG8gYWNjdW11bGF0ZWQgZW50cm9weS5cbiAgbWl4a2V5KHRvc3RyaW5nKGFyYzQuUyksIHBvb2wpO1xuXG4gIC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fFxuICAgICAgZnVuY3Rpb24ocHJuZywgc2VlZCwgaXNfbWF0aF9jYWxsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxuICAgICAgICAgIGlmIChzdGF0ZS5TKSB7IGNvcHkoc3RhdGUsIGFyYzQpOyB9XG4gICAgICAgICAgLy8gT25seSBwcm92aWRlIHRoZSAuc3RhdGUgbWV0aG9kIGlmIHJlcXVlc3RlZCB2aWEgb3B0aW9ucy5zdGF0ZS5cbiAgICAgICAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KGFyYzQsIHt9KTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY2FsbGVkIGFzIGEgbWV0aG9kIG9mIE1hdGggKE1hdGguc2VlZHJhbmRvbSgpKSwgbXV0YXRlXG4gICAgICAgIC8vIE1hdGgucmFuZG9tIGJlY2F1c2UgdGhhdCBpcyBob3cgc2VlZHJhbmRvbS5qcyBoYXMgd29ya2VkIHNpbmNlIHYxLjAuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHsgbWF0aFtybmduYW1lXSA9IHBybmc7IHJldHVybiBzZWVkOyB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBhIG5ld2VyIGNhbGxpbmcgY29udmVudGlvbiwgc28gcmV0dXJuIHRoZVxuICAgICAgICAvLyBwcm5nIGRpcmVjdGx5LlxuICAgICAgICBlbHNlIHJldHVybiBwcm5nO1xuICAgICAgfSkoXG4gIHBybmcsXG4gIHNob3J0c2VlZCxcbiAgJ2dsb2JhbCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2xvYmFsIDogKHRoaXMgPT0gbWF0aCksXG4gIG9wdGlvbnMuc3RhdGUpO1xufVxuXG4vL1xuLy8gQVJDNFxuLy9cbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2Zcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuLy9cbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4vL1xuZnVuY3Rpb24gQVJDNChrZXkpIHtcbiAgdmFyIHQsIGtleWxlbiA9IGtleS5sZW5ndGgsXG4gICAgICBtZSA9IHRoaXMsIGkgPSAwLCBqID0gbWUuaSA9IG1lLmogPSAwLCBzID0gbWUuUyA9IFtdO1xuXG4gIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXG4gIGlmICgha2V5bGVuKSB7IGtleSA9IFtrZXlsZW4rK107IH1cblxuICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuICB3aGlsZSAoaSA8IHdpZHRoKSB7XG4gICAgc1tpXSA9IGkrKztcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyBrZXlbaSAlIGtleWxlbl0gKyAodCA9IHNbaV0pKV07XG4gICAgc1tqXSA9IHQ7XG4gIH1cblxuICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG4gIChtZS5nID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cbiAgICB2YXIgdCwgciA9IDAsXG4gICAgICAgIGkgPSBtZS5pLCBqID0gbWUuaiwgcyA9IG1lLlM7XG4gICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgIHQgPSBzW2kgPSBtYXNrICYgKGkgKyAxKV07XG4gICAgICByID0gciAqIHdpZHRoICsgc1ttYXNrICYgKChzW2ldID0gc1tqID0gbWFzayAmIChqICsgdCldKSArIChzW2pdID0gdCkpXTtcbiAgICB9XG4gICAgbWUuaSA9IGk7IG1lLmogPSBqO1xuICAgIHJldHVybiByO1xuICAgIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSwgdGhlIGZ1bmN0aW9uIGNhbGwgYmVsb3cgYXV0b21hdGljYWxseVxuICAgIC8vIGRpc2NhcmRzIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLiAgVGhpcyBpcyBjYWxsZWQgUkM0LWRyb3BbMjU2XS5cbiAgICAvLyBTZWUgaHR0cDovL2dvb2dsZS5jb20vc2VhcmNoP3E9cnNhK2ZsdWhyZXIrcmVzcG9uc2UmYnRuSVxuICB9KSh3aWR0aCk7XG59XG5cbi8vXG4vLyBjb3B5KClcbi8vIENvcGllcyBpbnRlcm5hbCBzdGF0ZSBvZiBBUkM0IHRvIG9yIGZyb20gYSBwbGFpbiBvYmplY3QuXG4vL1xuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC5qID0gZi5qO1xuICB0LlMgPSBmLlMuc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG4vL1xuLy8gZmxhdHRlbigpXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXG4vL1xuZnVuY3Rpb24gZmxhdHRlbihvYmosIGRlcHRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSwgdHlwID0gKHR5cGVvZiBvYmopLCBwcm9wO1xuICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJyk7XG59XG5cbi8vXG4vLyBtaXhrZXkoKVxuLy8gTWl4ZXMgYSBzdHJpbmcgc2VlZCBpbnRvIGEga2V5IHRoYXQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGFuZFxuLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4vL1xuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xuICB2YXIgc3RyaW5nc2VlZCA9IHNlZWQgKyAnJywgc21lYXIsIGogPSAwO1xuICB3aGlsZSAoaiA8IHN0cmluZ3NlZWQubGVuZ3RoKSB7XG4gICAga2V5W21hc2sgJiBqXSA9XG4gICAgICBtYXNrICYgKChzbWVhciBePSBrZXlbbWFzayAmIGpdICogMTkpICsgc3RyaW5nc2VlZC5jaGFyQ29kZUF0KGorKykpO1xuICB9XG4gIHJldHVybiB0b3N0cmluZyhrZXkpO1xufVxuXG4vL1xuLy8gYXV0b3NlZWQoKVxuLy8gUmV0dXJucyBhbiBvYmplY3QgZm9yIGF1dG9zZWVkaW5nLCB1c2luZyB3aW5kb3cuY3J5cHRvIGFuZCBOb2RlIGNyeXB0b1xuLy8gbW9kdWxlIGlmIGF2YWlsYWJsZS5cbi8vXG5mdW5jdGlvbiBhdXRvc2VlZCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3V0O1xuICAgIGlmIChub2RlY3J5cHRvICYmIChvdXQgPSBub2RlY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xuICAgICAgLy8gVGhlIHVzZSBvZiAnb3V0JyB0byByZW1lbWJlciByYW5kb21CeXRlcyBtYWtlcyB0aWdodCBtaW5pZmllZCBjb2RlLlxuICAgICAgb3V0ID0gb3V0KHdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgYnJvd3NlciA9IGdsb2JhbC5uYXZpZ2F0b3IsXG4gICAgICAgIHBsdWdpbnMgPSBicm93c2VyICYmIGJyb3dzZXIucGx1Z2lucztcbiAgICByZXR1cm4gWytuZXcgRGF0ZSwgZ2xvYmFsLCBwbHVnaW5zLCBnbG9iYWwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XG4gIH1cbn1cblxuLy9cbi8vIHRvc3RyaW5nKClcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xuLy9cbmZ1bmN0aW9uIHRvc3RyaW5nKGEpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCwgYSk7XG59XG5cbi8vXG4vLyBXaGVuIHNlZWRyYW5kb20uanMgaXMgbG9hZGVkLCB3ZSBpbW1lZGlhdGVseSBtaXggYSBmZXcgYml0c1xuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cbi8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbi8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXG4vLyBpbml0aWFsaXphdGlvbi5cbi8vXG5taXhrZXkobWF0aC5yYW5kb20oKSwgcG9vbCk7XG5cbi8vXG4vLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4vLyBlaXRoZXIgY29udmVudGlvbi5cbi8vXG5pZiAoKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gc2VlZHJhbmRvbTtcbiAgLy8gV2hlbiBpbiBub2RlLmpzLCB0cnkgdXNpbmcgY3J5cHRvIHBhY2thZ2UgZm9yIGF1dG9zZWVkaW5nLlxuICB0cnkge1xuICAgIG5vZGVjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgfSBjYXRjaCAoZXgpIHt9XG59IGVsc2UgaWYgKCh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VlZHJhbmRvbTsgfSk7XG59IGVsc2Uge1xuICAvLyBXaGVuIGluY2x1ZGVkIGFzIGEgcGxhaW4gc2NyaXB0LCBzZXQgdXAgTWF0aC5zZWVkcmFuZG9tIGdsb2JhbC5cbiAgbWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207XG59XG5cblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KShcbiAgLy8gZ2xvYmFsOiBgc2VsZmAgaW4gYnJvd3NlcnMgKGluY2x1ZGluZyBzdHJpY3QgbW9kZSBhbmQgd2ViIHdvcmtlcnMpLFxuICAvLyBvdGhlcndpc2UgYHRoaXNgIGluIE5vZGUgYW5kIG90aGVyIGVudmlyb25tZW50c1xuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSA/IHNlbGYgOiB0aGlzLFxuICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4pO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsInBvb2wiLCJtYXRoIiwid2lkdGgiLCJjaHVua3MiLCJkaWdpdHMiLCJybmduYW1lIiwic3RhcnRkZW5vbSIsInBvdyIsInNpZ25pZmljYW5jZSIsIm92ZXJmbG93IiwibWFzayIsIm5vZGVjcnlwdG8iLCJzZWVkcmFuZG9tIiwic2VlZCIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImtleSIsImVudHJvcHkiLCJzaG9ydHNlZWQiLCJtaXhrZXkiLCJmbGF0dGVuIiwidG9zdHJpbmciLCJhdXRvc2VlZCIsImFyYzQiLCJBUkM0IiwicHJuZyIsIm4iLCJnIiwiZCIsIngiLCJpbnQzMiIsInF1aWNrIiwiZG91YmxlIiwiUyIsInBhc3MiLCJpc19tYXRoX2NhbGwiLCJzdGF0ZSIsImNvcHkiLCJ0Iiwia2V5bGVuIiwibGVuZ3RoIiwibWUiLCJpIiwiaiIsInMiLCJjb3VudCIsInIiLCJmIiwic2xpY2UiLCJvYmoiLCJkZXB0aCIsInJlc3VsdCIsInR5cCIsInByb3AiLCJwdXNoIiwiZSIsInN0cmluZ3NlZWQiLCJzbWVhciIsImNoYXJDb2RlQXQiLCJvdXQiLCJyYW5kb21CeXRlcyIsIlVpbnQ4QXJyYXkiLCJjcnlwdG8iLCJtc0NyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsImJyb3dzZXIiLCJuYXZpZ2F0b3IiLCJwbHVnaW5zIiwiRGF0ZSIsInNjcmVlbiIsImEiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsInJhbmRvbSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiZXgiLCJkZWZpbmUiLCJhbWQiLCJzZWxmIiwiTWF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/seedrandom.js\n");

/***/ })

};
;